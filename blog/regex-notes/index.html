<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!-- Consider adding an manifest.appcache: h5bp.com/d/Offline -->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <!-- Use the .htaccess and remove these lines to avoid edge case issues.
       More info: h5bp.com/b/378 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Regex Notes |  kim hirokuni</title>
  <meta name="author" content="kim hirokuni">
  

  
  <!-- Mobile viewport optimized: j.mp/bplateviewport -->
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- Place favicon.ico and apple-touch-icon.png in the root directory: mathiasbynens.be/notes/touch-icons -->
  <link href="/favicon.png" rel="icon">

  <!-- CSS: implied media=all -->
  <!-- CSS concatenated and minified via ant build script-->
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
  <!-- end CSS-->

  <!-- More ideas for your <head> here: h5bp.com/d/head-Tips -->

  <!-- All JavaScript at the bottom, except for Modernizr / Respond.
       Modernizr enables HTML5 elements & feature detects; Respond is a polyfill for min/max-width CSS3 Media Queries
       For optimal performance, use a custom Modernizr build: www.modernizr.com/download/ -->
  <script src="/javascripts/libs/modernizr-2.0.6.min.js"></script>
</head>

<body id="post">

  <div id="container">
    <nav role="navigation" ><ul class="main-navigation">
  <li style='float:left;margin-right:5px'><a class='nav' href="/">Home</a></li>
</ul><br><br>
</nav>
    <article>


  <h1 class="article-title">Regex Notes</h1>
  <div class="article-content"><h2>基本動作</h2>

<ul>
<li>Regex Engine</li>
<li>Regexデータ</li>
<li>文字列データ</li>
</ul>


<p>この三つがメインでEngineがRegexデータと文字列データをひとつずつチェックしていく。<strong>マッチ</strong>というのはRegex全体で表現されるパターンが全体でマッチしている場合のことをいう。(ただ各Regexがマッチしている場合もマッチともいう)。わかりづらいので各Regexがマッチしていることは成功といいダメな時は失敗と呼ぶ。</p>

<p>以下はもっとも基本なマッチ。</p>

<h2>Regex基本原則</h2>

<p>まずはRegexの基本原則を見てみる。しかし、これらの基本原則はオプションによって変化して、場合ごとに考え方を変えないといけないところにRegexの難しがあると思う。ただ、基本原則をしっかり理解しておけば、変化系にも対応しやすくなる。</p>

<h3>左から一文字ずつマッチしていく</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/ab/
</span><span class='line'>ab</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>"ab"</code>にマッチした。</li>
</ol>


<p>Regex EngineはRegexデータ、文字列ともに現在のステップのポジションを覚えていて、ステップ毎にそれらのポジションをひとつずつずらしていく。ポジションは左から右に動いていく。</p>

<h3>マッチした時点で終了</h3>

<p>マッチが達成されたら、それ以降の文字列は無視する。これを貪欲でないマッチとか一般的には呼ぶが自分にはどうもわかりずらい。代わりに<strong>せっかちマッチ</strong>と覚えている。せっかちなので一度マッチした時点で<strong>マッチしたよ！</strong>と言って仕事を終わってしまう。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/ab/
</span><span class='line'>abab</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>主なEngineではデフォルトではLazy、つまりマッチが成功した時点で終わる</li>
<li>終了</li>
<li>結果: 最初の<code>"ab"</code>だけにマッチした。</li>
</ol>


<h3>マッチが成功するために全ての可能性を試す</h3>

<p>Regexにとって一番大事な仕事はマッチする文字列を探すこと。それを達成するためにRegexは全ての可能性を試す。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/ab/
</span><span class='line'>acab</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"c"</code> => 失敗</li>
<li>失敗したのでRegexの最初に戻ってマッチさせようとする。これをBacktrackと呼ぶ。Backtrack == 巻き戻し と考えればいい</li>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>"ab"</code>にマッチした。</li>
</ol>


<h2>よく使われる応用Regex</h2>

<p>ここからは実際によく使うRegexを紹介。中には基本原則で紹介した動作を変えるものもあるので、場合ごとに動作がどう変わるかを把握しないといけない。</p>

<h3>g を使うと一度マッチしても続けてマッチさせようとする（貪欲マッチ)</h3>

<p>Regexの最後に <code>g</code> をつけると一度マッチしても終了せず続けてマッチさせようとする。<code>g</code>を修飾子と呼びこの動作を貪欲マッチと呼ぶ。せっかちマッチの場合と同じでわかりにくいので<strong>熱心マッチ</strong>と覚える。これは基本動作のせっかちマッチを変える。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/ab/g
</span><span class='line'>abab</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>熱心モードなので文字列がある残っている以上つづける。</li>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>"abab"</code>にマッチした。</li>
</ol>


<h3>文字だけじゃなくその位置を含めて成功/失敗を判定（アンカー）</h3>

<p>今まで見てきたRegexは同じ文字かどうかを判定するものだった。例えば、<code>/ab/</code>はaのあとにbが続く<code>"ab"</code>にマッチする。言い換えれば、aのあとにbが続く限りそれがどこにあろうがマッチする。だから<code>"1ab2</code>はこの場合マッチする。</p>

<p><code>^</code>と<code>$</code>がRegexの前につくと文字のマッチだけじゃなくその文字がある位置まで見る。こうゆう種類のRegexをアンカーと呼ぶ。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/^a/
</span><span class='line'>1a</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>^a</code> 文字列: <code>"1"</code> => 失敗</li>
<li>BacktrackでRegexが最初に戻る。</li>
<li>Regex: <code>^a</code> 文字列: <code>"a"</code> => 失敗</li>
<li><code>"a"</code>にはマッチしているが <code>^a</code>は一番最初にある<code>"a"</code>なので失敗。</li>
<li>終了</li>
<li>結果: マッチなし</li>
</ol>


<h3>改行直後の文字は最初の文字列ではない</h3>

<p><code>^</code>は文字列の最初の位置にマッチするが、改行直後の文字列は最初の文字とはならない。この動作が主なRegexエンジンのデフォルト。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/^a/
</span><span class='line'>
</span><span class='line'># 複数行に渡る文字列
</span><span class='line'>1a
</span><span class='line'>a
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>^a</code> 文字列: <code>"1"</code> => 失敗</li>
<li>BacktrackでRegexが最初に戻る。</li>
<li>Regex: <code>^a</code> 文字列: <code>"a"</code> => 失敗</li>
<li>BacktrackでRegexが最初に戻る。</li>
<li>Regex: <code>^a</code> 文字列: <code>"a"</code> => 失敗</li>
<li><code>^a</code>はあくまで文字列全体の最初にある<code>"a"</code>。二つ目の<code>"a"</code>は行の最初のaだが文字列全体の最初ではないのでマッチしない。</li>
<li>終了</li>
<li>結果: マッチなし</li>
</ol>


<h3>mを使うと改行が入っていても最初の文字とみなす</h3>

<p>上で例だと改行直後、二つ目の<code>"a"</code>は<code>/^a/</code>にはマッチしなかった。これをマッチさせるには<code>m</code>修飾子を使う。すると、改行直後の文字でも文字列の最初とみなされる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/^a/m
</span><span class='line'>
</span><span class='line'># 複数行に渡る文字列
</span><span class='line'>1a
</span><span class='line'>a</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>^a</code> 文字列: <code>"1"</code> => 失敗</li>
<li>BacktrackでRegexが最初に戻る。</li>
<li>Regex: <code>^a</code> 文字列: <code>"a"</code> => 成功</li>
<li><code>m</code>修飾子があるので改行直後の<code>"a"</code>は文字列の最初とみなされる。</li>
<li>終了</li>
<li>結果: 二つ目の<code>a</code>にマッチ</li>
</ol>


<p><code>m</code>を使った時の動作をmulti-lineモードと呼ぶ。</p>

<h3>（ほぼ）どんな文字にもマッチする . (ドット)</h3>

<p>どんな文字にでもマッチするRegexに<code>.</code>がある。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/.../
</span><span class='line'>1&!</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>.</code> 文字列: <code>"1"</code> => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>"&amp;"</code> => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>"!"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>1&amp;!</code>にマッチ</li>
</ol>


<p>しかし<code>.</code>にも例外はあり改行にはマッチしない。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/.../
</span><span class='line'># 複数行に渡る文字列
</span><span class='line'>1
</span><span class='line'>2</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>.</code> 文字列: <code>"1"</code> => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>\n</code>  => 失敗</li>
<li>Backtrackで最初の <code>.</code>に戻る</li>
<li>Regex: <code>.</code> 文字列: <code>"2"</code> => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>\n</code>  => 失敗</li>
<li>終了</li>
<li>結果: マッチなし</li>
</ol>


<h3>s を使うと . (ドット)が改行にもマッチする</h3>

<p><code>s</code>修飾子を使うと<code>.</code>が改行にもマッチするようになる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/.../s
</span><span class='line'># 複数行に渡る文字列
</span><span class='line'>1
</span><span class='line'>2</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>.</code> 文字列: <code>"1"</code> => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>\n</code>  => 成功</li>
<li>Regex: <code>.</code> 文字列: <code>"2"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>1\n2</code>にマッチ</li>
</ol>


<p><code>s</code>を使った時の動作をsingle-lineモードと呼ぶ。注意するのは single-modeとmulti-lineモードは全く別物だということ。single-lineモードは<code>.</code>が改行も含むようにすることに対して、multi-lineモードはアンカー (<code>^</code>や<code>&amp;</code>)が改行を考慮するするようにすることなので、single-lineとmulti-lineは相反するモードではない。（両方指定可能)</p>

<h3>パターンを繰り返す</h3>

<p><code>+</code>や<code>*</code>を使うとその直前のRegexを繰り返してマッチするようにできる。<code>+</code>は直前のRegexの一回以上の繰り返し。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/a+/
</span><span class='line'>aaa</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a+</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>a+</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>a+</code> 文字列: <code>"a"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>"aaa"</code>にマッチ</li>
</ol>


<p><code>*</code>は直前のRegexの0回以上に繰り返し。つまりマッチする文字がなくても成功になる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/a*b/
</span><span class='line'>b</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a*</code> 文字列: <code>"b"</code> => 成功</li>
<li><code>*</code>は0回以上のaの繰り返せば成功、つまりaがなくても成功とみなす。</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code> => 成功</li>
<li>終了</li>
<li>結果: <code>"b"</code>にマッチ</li>
</ol>


<h3>Regexの最後に行く前に文字が終わってしまったら文字を戻す</h3>

<p><code>.</code>と<code>+</code>や<code>*</code>を組み合わせると任意の文字の無限の繰り返しを指定できるので文字列のほうが先に終わってしまうことがある。Regexが失敗したときはBacktrackして次の文字からまたやり直したが繰り返しを使うと文字の方を巻き戻す。普通のBacktrackと区別するために文字列Backtrackと呼ぶ。Regexがこうゆう動きをするのは、最初に書いた<strong>マッチが成功するために全ての可能性を試す</strong>という基本原則があるから。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/a.+b/
</span><span class='line'>aab</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>.+</code> 文字列: <code>"a"</code> => 成功</li>
<li><code>.+</code>は任意の文字の繰り返しなので次のRegexには進まない。</li>
<li>Regex: <code>.+</code> 文字列: <code>"b"</code> => 成功</li>
<li>この時点で文字列が終わってしまったが、Regex側は<code>b</code>がまだ残っている。<code>b</code>まで成功しないとマッチではない。</li>
<li>文字列をマッチするとわかっているところまでBacktrackする(この場合最初の<code>"aa"</code>が<code>/a.+/</code>でマッチするとわかっているのでここまで戻す。）</li>
<li>Regex: <code>b</code> 文字列: <code>"b"</code>=> 成功</li>
<li>終了</li>
<li>結果: <code>"aab"</code>にマッチ</li>
</ol>


<h2>もし ~ ならマッチを試みる</h2>

<p>ここまで紹介したRegexではプログラミングでつかう<code>IF ~ then ~ END</code>のようなことはできない。それをできるようにするのがLookahead。重要なポイントはLookaheadは条件をしていしるだけなのでそれ自体はマッチの結果には含まれない。</p>

<h3>もしXにYがつづけばマッチ (Positive Lookahead)</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/a(?=b)/
</span><span class='line'>abd</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>a</code> 文字列: <code>"a"</code> => 成功</li>
<li>Regex: <code>(?=b)</code>の<code>b</code>の部分 文字列: <code>"b"</code> => 成功</li>
<li>Regex: <code>(?=b)</code>の<code>?=</code>の部分 上のステップで<code>b</code>がマッチしたら成功 => 成功</li>
<li>終了</li>
<li>結果: <code>"a"</code>にマッチ。<strong>bはあくまで条件なのでb自体にはマッチしない</strong></li>
</ol>


<p>この例ではあまり意味があるように思えないがLookaheadはXが続かないYを探す時に真価を発揮する。</p>

<h3>もしXにYがつづかなければマッチ (Negative Lookahead)</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>q(?!u)
</span><span class='line'>aq</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Regex: <code>q</code> 文字列: <code>"a"</code> => 失敗</li>
<li>Backtrack</li>
<li>Regex: <code>q</code> 文字列: <code>"q"</code> => 成功</li>
<li>Regex: <code>(?!=u)</code>の<code>u</code>の部分 文字列: <code>"u"</code> => 失敗</li>
<li>Regex: <code>(?!u)</code>の<code>?!</code>の部分 上のステップで<code>u</code>がマッチしていないから成功 => 成功</li>
<li>終了</li>
<li>結果: <code>"q"</code>にマッチ</li>
</ol>

</div>
  
    <section>
      <h1>Comments</h1>
      <div id="disqus_thread"><div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'kimstechblog';
  var disqus_identifier = 'http://kimh.github.io/blog/regex-notes/';
  var disqus_url = 'http://kimh.github.io/blog/regex-notes/';
  //var disqus_developer = 1;
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </section>
  

</article>


      <p class="meta">
      
        <a class="basic-alignment left nav" href="/blog/make-elm-app/" title="Previous Post: CollageとAnimationを使ってElmでアプリを作る">&laquo; CollageとAnimationを使ってElmでアプリを作る</a>
      
      
        <a class="basic-alignment right nav" href="/blog/2018-review/" title="Next Post: 2018 Review">2018 Review &raquo;</a>
      
    </p>
  </div>
    <script>
      var name = document.getElementById('name-helper').innerHTML;

      var canvas = document.getElementById('myCanvas');

      //The name (up to 28 characters long, including white space)
      var length = name.length;
      if (length>28){//Exceed character length limit, remove canvas
          canvas.remove();
      }
      else{
            

        var context = canvas.getContext('2d');

        //calculate width and length
        var width=700/1.25/length;
        var start;
        if (width>40){
          width=40;
        }

        var height= width/2;

        //the start postion of the link list
        var start = (700-width*length*1.25)/2;
        var horizon = 5;

        //DO NOT CHANGE THOSE
        var mid_horizon = horizon+height/2;
        var name_counter =0;

        var x = height/5;
        var y = height/5;
        var interval=width/4;
        
        var radius = 0.75*width;
        
        var text_pos=width*1.1;


        canvas.height=mid_horizon+width/2+width/2.1+5;
        
        for (var i=1;i<name.length+1;i++){

          context.beginPath();
          context.strokeStyle='#F9BF3B';
          
          //the rectangle
          context.rect(start, horizon, width, height);

          //the middle line
          context.moveTo(start+width/2,horizon);
          context.lineTo(start+width/2,horizon+height);

          //if this is the last element
          if (i==name.length){
            context.moveTo(start+width/2,horizon+height);
            context.lineTo(start+width,horizon);

          }
          else{
            //the arrow
            context.moveTo(start+0.75*width,mid_horizon);
            context.lineTo(start+width+interval,mid_horizon);

            context.moveTo(start+width+interval,mid_horizon);
            context.lineTo(start+width+interval-x,mid_horizon+y);
          
            context.moveTo(start+width+interval,mid_horizon);
            context.lineTo(start+width+interval-x,mid_horizon-y); 
          }
          
       
        
          var startAngle = 1.2 * Math.PI;
          var endAngle = 1 * Math.PI;
          var counterClockwise = true;
      
          context.stroke();
            
          context.beginPath();
          context.arc(start+width/4+radius*0.81, mid_horizon+width/2, radius, startAngle, endAngle, counterClockwise);

          context.moveTo(start+width/4+radius*0.81-radius,mid_horizon+width/2);
          context.lineTo(start+width/4+radius*0.81-radius-x,mid_horizon-y+width/2);

          context.moveTo(start+width/4+radius*0.81-radius,mid_horizon+width/2);
          context.lineTo(start+width/4+radius*0.81-radius+x,mid_horizon-y+width/2); 

          context.font = ' 15pt Calibri';
          context.fillStyle = '#859900';
          context.fillText(name.charAt(name_counter), start+width/4+radius*0.81-radius-width/14, mid_horizon+width/2+width/2.1);

          context.lineWidth=1;
          context.strokeStyle='#F9BF3B';
          context.stroke();
          start+=width/2*2+interval;      
          name_counter+=1;
        }
      }

    </script>

  <!-- JavaScript at the bottom for fast page loading -->

  <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if offline -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery-1.6.2.min.js"><\/script>')</script>


  <!-- scripts concatenated and minified via ant build script-->
  <script defer src="/javascripts/app.js"></script>
  <!-- end scripts-->

	

  <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.
       chromium.org/developers/how-tos/chrome-frame-getting-started -->
  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->
 

  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>







</body>
</html>

