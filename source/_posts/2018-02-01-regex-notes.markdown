---
layout: post
title: "Regex Notes"
date: 2018-02-01 22:01
comments: true
categories: 
---

## 基本動作

- Regex Engine
- Regexデータ
- 文字列データ

この三つがメインでEngineがRegexデータと文字列データをひとつずつチェックしていく。**マッチ**というのはRegex全体で表現されるパターンが全体でマッチしている場合のことをいう。(ただ各Regexがマッチしている場合もマッチともいう)。わかりづらいので各Regexがマッチしていることは成功といいダメな時は失敗と呼ぶ。

以下はもっとも基本なマッチ。

## Regex基本原則

まずはRegexの基本原則を見てみる。しかし、これらの基本原則はオプションによって変化して、場合ごとに考え方を変えないといけないところにRegexの難しがあると思う。ただ、基本原則をしっかり理解しておけば、変化系にも対応しやすくなる。

### 左から一文字ずつマッチしていく

```
/ab/
ab
```

1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"b"` => 成功
1. 終了
1. 結果: `"ab"`にマッチした。

Regex EngineはRegexデータ、文字列ともに現在のステップのポジションを覚えていて、ステップ毎にそれらのポジションをひとつずつずらしていく。ポジションは左から右に動いていく。

### マッチした時点で終了

マッチが達成されたら、それ以降の文字列は無視する。これを貪欲でないマッチとか一般的には呼ぶが自分にはどうもわかりずらい。代わりに**せっかちマッチ**と覚えている。せっかちなので一度マッチした時点で**マッチしたよ！**と言って仕事を終わってしまう。
```
/ab/
abab
```

1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"b"` => 成功
1. 主なEngineではデフォルトではLazy、つまりマッチが成功した時点で終わる
1. 終了
1. 結果: 最初の`"ab"`だけにマッチした。

### マッチが成功するために全ての可能性を試す

Regexにとって一番大事な仕事はマッチする文字列を探すこと。それを達成するためにRegexは全ての可能性を試す。

```
/ab/
acab
```

1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"c"` => 失敗
1. 失敗したのでRegexの最初に戻ってマッチさせようとする。これをBacktrackと呼ぶ。Backtrack == 巻き戻し と考えればいい
1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"b"` => 成功
1. 終了
1. 結果: `"ab"`にマッチした。

## よく使われる応用Regex

ここからは実際によく使うRegexを紹介。中には基本原則で紹介した動作を変えるものもあるので、場合ごとに動作がどう変わるかを把握しないといけない。

### g を使うと一度マッチしても続けてマッチさせようとする（貪欲マッチ)

Regexの最後に `g` をつけると一度マッチしても終了せず続けてマッチさせようとする。`g`を修飾子と呼びこの動作を貪欲マッチと呼ぶ。せっかちマッチの場合と同じでわかりにくいので**熱心マッチ**と覚える。これは基本動作のせっかちマッチを変える。

```
/ab/g
abab
```

1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"b"` => 成功
1. 熱心モードなので文字列がある残っている以上つづける。
1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `b` 文字列: `"b"` => 成功
1. 終了
1. 結果: `"abab"`にマッチした。

### 文字だけじゃなくその位置を含めて成功/失敗を判定（アンカー）

今まで見てきたRegexは同じ文字かどうかを判定するものだった。例えば、`/ab/`はaのあとにbが続く`"ab"`にマッチする。言い換えれば、aのあとにbが続く限りそれがどこにあろうがマッチする。だから`"1ab2`はこの場合マッチする。

`^`と`$`がRegexの前につくと文字のマッチだけじゃなくその文字がある位置まで見る。こうゆう種類のRegexをアンカーと呼ぶ。

```
/^a/
1a
```

1. Regex: `^a` 文字列: `"1"` => 失敗
1. BacktrackでRegexが最初に戻る。
1. Regex: `^a` 文字列: `"a"` => 失敗
1. `"a"`にはマッチしているが `^a`は一番最初にある`"a"`なので失敗。
1. 終了
1. 結果: マッチなし

### 改行直後の文字は最初の文字列ではない

`^`は文字列の最初の位置にマッチするが、改行直後の文字列は最初の文字とはならない。この動作が主なRegexエンジンのデフォルト。

```
/^a/

# 複数行に渡る文字列
1a
a


```

1. Regex: `^a` 文字列: `"1"` => 失敗
1. BacktrackでRegexが最初に戻る。
1. Regex: `^a` 文字列: `"a"` => 失敗
1. BacktrackでRegexが最初に戻る。
1. Regex: `^a` 文字列: `"a"` => 失敗
1. `^a`はあくまで文字列全体の最初にある`"a"`。二つ目の`"a"`は行の最初のaだが文字列全体の最初ではないのでマッチしない。
1. 終了
1. 結果: マッチなし

### mを使うと改行が入っていても最初の文字とみなす

上で例だと改行直後、二つ目の`"a"`は`/^a/`にはマッチしなかった。これをマッチさせるには`m`修飾子を使う。すると、改行直後の文字でも文字列の最初とみなされる。

```
/^a/m

# 複数行に渡る文字列
1a
a
```

1. Regex: `^a` 文字列: `"1"` => 失敗
1. BacktrackでRegexが最初に戻る。
1. Regex: `^a` 文字列: `"a"` => 成功
1. `m`修飾子があるので改行直後の`"a"`は文字列の最初とみなされる。
1. 終了
1. 結果: 二つ目の`a`にマッチ

`m`を使った時の動作をmulti-lineモードと呼ぶ。

### （ほぼ）どんな文字にもマッチする . (ドット)

どんな文字にでもマッチするRegexに`.`がある。

```
/.../
1&!
```

1. Regex: `.` 文字列: `"1"` => 成功
1. Regex: `.` 文字列: `"&"` => 成功
1. Regex: `.` 文字列: `"!"` => 成功
1. 終了
1. 結果: `1&!`にマッチ

しかし`.`にも例外はあり改行にはマッチしない。

```
/.../
# 複数行に渡る文字列
1
2
```

1. Regex: `.` 文字列: `"1"` => 成功
1. Regex: `.` 文字列: `\n`  => 失敗
1. Backtrackで最初の `.`に戻る
1. Regex: `.` 文字列: `"2"` => 成功
1. Regex: `.` 文字列: `\n`  => 失敗
1. 終了
1. 結果: マッチなし

### s を使うと . (ドット)が改行にもマッチする

`s`修飾子を使うと`.`が改行にもマッチするようになる。

```
/.../s
# 複数行に渡る文字列
1
2
```

1. Regex: `.` 文字列: `"1"` => 成功
1. Regex: `.` 文字列: `\n`  => 成功
1. Regex: `.` 文字列: `"2"` => 成功
1. 終了
1. 結果: `1\n2`にマッチ

`s`を使った時の動作をsingle-lineモードと呼ぶ。注意するのは single-modeとmulti-lineモードは全く別物だということ。single-lineモードは`.`が改行も含むようにすることに対して、multi-lineモードはアンカー (`^`や`&`)が改行を考慮するするようにすることなので、single-lineとmulti-lineは相反するモードではない。（両方指定可能)

### パターンを繰り返す

`+`や`*`を使うとその直前のRegexを繰り返してマッチするようにできる。`+`は直前のRegexの一回以上の繰り返し。

```
/a+/
aaa
```

1. Regex: `a+` 文字列: `"a"` => 成功
1. Regex: `a+` 文字列: `"a"` => 成功
1. Regex: `a+` 文字列: `"a"` => 成功
1. 終了
1. 結果: `"aaa"`にマッチ

`*`は直前のRegexの0回以上に繰り返し。つまりマッチする文字がなくても成功になる。

```
/a*b/
b
```

1. Regex: `a*` 文字列: `"b"` => 成功
1. `*`は0回以上のaの繰り返せば成功、つまりaがなくても成功とみなす。
1. Regex: `b` 文字列: `"b"` => 成功
1. 終了
1. 結果: `"b"`にマッチ

### Regexの最後に行く前に文字が終わってしまったら文字を戻す

`.`と`+`や`*`を組み合わせると任意の文字の無限の繰り返しを指定できるので文字列のほうが先に終わってしまうことがある。Regexが失敗したときはBacktrackして次の文字からまたやり直したが繰り返しを使うと文字の方を巻き戻す。普通のBacktrackと区別するために文字列Backtrackと呼ぶ。Regexがこうゆう動きをするのは、最初に書いた**マッチが成功するために全ての可能性を試す**という基本原則があるから。

```
/a.+b/
aab
```
1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `.+` 文字列: `"a"` => 成功
1. `.+`は任意の文字の繰り返しなので次のRegexには進まない。
1. Regex: `.+` 文字列: `"b"` => 成功
1. この時点で文字列が終わってしまったが、Regex側は`b`がまだ残っている。`b`まで成功しないとマッチではない。
1. 文字列をマッチするとわかっているところまでBacktrackする(この場合最初の`"aa"`が`/a.+/`でマッチするとわかっているのでここまで戻す。）
1. Regex: `b` 文字列: `"b"`=> 成功
1. 終了
1. 結果: `"aab"`にマッチ

## もし ~ ならマッチを試みる

ここまで紹介したRegexではプログラミングでつかう`IF ~ then ~ END`のようなことはできない。それをできるようにするのがLookahead。重要なポイントはLookaheadは条件をしていしるだけなのでそれ自体はマッチの結果には含まれない。

### もしXにYがつづけばマッチ (Positive Lookahead)

```
/a(?=b)/
abd
```

1. Regex: `a` 文字列: `"a"` => 成功
1. Regex: `(?=b)`の`b`の部分 文字列: `"b"` => 成功
1. Regex: `(?=b)`の`?=`の部分 上のステップで`b`がマッチしたら成功 => 成功
1. 終了
1. 結果: `"a"`にマッチ。**bはあくまで条件なのでb自体にはマッチしない**

この例ではあまり意味があるように思えないがLookaheadはXが続かないYを探す時に真価を発揮する。

### もしXにYがつづかなければマッチ (Negative Lookahead)

```
q(?!u)
aq
```

1. Regex: `q` 文字列: `"a"` => 失敗
1. Backtrack
1. Regex: `q` 文字列: `"q"` => 成功
1. Regex: `(?!=u)`の`u`の部分 文字列: `"u"` => 失敗
1. Regex: `(?!u)`の`?!`の部分 上のステップで`u`がマッチしていないから成功 => 成功
1. 終了
1. 結果: `"q"`にマッチ
