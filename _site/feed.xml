<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-02-26T13:40:21+09:00</updated><id>/feed.xml</id><title type="html">Program Is Made At Night</title><subtitle>Blog about programming, problem solving, e-scooter, and other random things that I love</subtitle><author><name>kim hirokuni</name></author><entry><title type="html">CircleCI Orbsを使ってECR/ECSへ自動デプロイする</title><link href="/blog/ecr-ecs-orbs/" rel="alternate" type="text/html" title="CircleCI Orbsを使ってECR/ECSへ自動デプロイする" /><published>2019-02-26T11:21:00+09:00</published><updated>2019-02-26T11:21:00+09:00</updated><id>/blog/ecr-ecs-orbs</id><content type="html" xml:base="/blog/ecr-ecs-orbs/"><![CDATA[<h1 id="モチベーション">モチベーション</h1>

<p>JAWS Days 2019でCircleCI Orbsを使ってAWSと連携されるネタで登壇してきました。当日の前日Twitterで公開することを約束しちゃったので、それならしっかりしたやつ作ろうということでブログ化しました。当日のスライドは<a href="https://speakerdeck.com/kimh/orbswoshi-tuteawshejian-dan-depuroi">ここ</a>。</p>

<p><img src="/assets/ecr_ecs_tweet.png" alt="tweet" />
https://twitter.com/inokara/status/1098529153890963458</p>

<h1 id="やりたいこと">やりたいこと</h1>

<p>CircleCIとECR、ECSを連携させて変更が自動でデプロイされるようにする。めっちゃ雑だけど以下のような感じの構成。</p>

<p><img src="/assets/ecs_ecr_diagram.png" alt="diagram" /></p>

<p>流れとしては</p>

<ul>
  <li>リポジトリのDockerイメージをアップデート</li>
  <li>GitHubへプッシュ</li>
  <li>CircleCIでイメージをビルドしてECRへプッシュ</li>
  <li>CircleCIで新しいイメージを使ってECSのタスク定義を更新してECSへプッシュ</li>
  <li>ブラザウから変更を確認</li>
</ul>

<p>これをするためにECR/ECS側とCircleCI側の設定が必要になる。</p>

<h1 id="ecr側の設定">ECR側の設定</h1>

<p>まずはECR側の設定。普通にリポジトリをECRで作るだけなので特別説明が必要なところはない。ひとつあるとすると、この時に設定する <code class="language-plaintext highlighter-rouge">Repository name</code> と<code class="language-plaintext highlighter-rouge">URI (1234567.dkr.ecr.us-east-1.amazonaws.com/nginx みたいなやつ)</code> はCircleCIの設定の時に必要になるくらい。</p>

<h1 id="ecs側の設定">ECS側の設定</h1>

<p>自分のAWS力が低すぐるってのもあるんだろうけど、ちょっとハマったのでこっちは詳しく解説してみようか。</p>

<p>ECSには大きく分けて3つのコンポーネントがあって、Cluster → Service → Task の順でより粒度が細かくなっていく。Taskには主に実行するコンテナに関する情報を、ServiceにはどのTaskを何個起動するかやLBと連携して負荷分散などの情報を、Clusterはそれらを実行するEC2インスタンスに関する情報をそれぞれ定義する。これらの理解については<a href="https://qiita.com/NewGyu/items/9597ed2eda763bd504d7">このQiitaの記事</a>がわかりやすかった。</p>

<h2 id="taskの作成">Taskの作成</h2>
<ul>
  <li>Create new Task Definition: EC2を選択 (Fargateよくわからん)</li>
  <li>Task Definition Name*: 適当な名前をつける。この記事では <code class="language-plaintext highlighter-rouge">kim-app-nginx</code> にする</li>
  <li>Task Role: <code class="language-plaintext highlighter-rouge">ecsTaskRoleExecution</code> を選択。</li>
  <li>Network Mode: <code class="language-plaintext highlighter-rouge">&lt;default&gt;</code> を選択。</li>
  <li>Task execution role: <code class="language-plaintext highlighter-rouge">ecsTaskExecutionRole</code> を選択。</li>
  <li>Task memory/ CPU: 適当に。</li>
</ul>

<p>Add containerボタンを押してコンテナイメージを入力していく。</p>

<ul>
  <li>Container name: 適当につける</li>
  <li>Image: ECRで作成したリポジトリを書く。<strong>注意するのはURI/リポジトリ:タグ</strong> の形式で書く。この記事では例として <code class="language-plaintext highlighter-rouge">1234567.dkr.ecr.us-east-1.amazonaws.com/nginx:latest</code> としておく。</li>
  <li>Port mappings: Host Portに0、Container PortにそのコンテナがListenするポートを書く。nginxの場合はContainer Portは80。<strong>Host Portを0をするところが重要。後述するけどこれをしないと複数のTaskを立てた時にポートがバッティングしてしまい自動デプロイに失敗する。</strong></li>
</ul>

<h2 id="clusterの作成">Clusterの作成</h2>
<p>Serviceを作る前にまずClusterを作成する。</p>

<p>Create Clusterから <strong>EC2 Linux + Networking</strong> を選択。ここはあんまり迷うところないと思うけどContainer instance IAM roleには <code class="language-plaintext highlighter-rouge">ecsInstanceRole</code> が選択されていることを確認。Cluster nameは適当につける。このブログでは <code class="language-plaintext highlighter-rouge">default-kim</code> とする。</p>

<p>Clusterが作成してしばらくするとECS Instancesのところで新しいEC2インスタンスが起動される（はず。もし起動されなかったらScale ECS Instancesを押してみて）</p>

<h2 id="load-balancerの作成">Load Balancerの作成</h2>

<p>唐突にLBの話が出てきたけど、これにはちゃんと理由がある。本来であればClusterを作成したら紐づくServiceを作成する。自動デプロイなしでとりあえずECSを動かすだけならそれでいいんだけど今回はCircleCIから自動デプロイすることが最終ゴールで、これをするためにLBが必要になる。</p>

<p>まずは問題を説明しよう。LBなしでServiceを作って自動デプロイすると以下のようなログが出て新しいタスクが起動しなかった。</p>

<p><code class="language-plaintext highlighter-rouge">service MYSERVICE was unable to place a task because no container instance met all of its requirements. The closest matching container-instance .... is already using a port required by your task</code></p>

<p>エラーメッセージにあるように、新しいタスクのポートが古いタスクとコンフリクトしてしまい、起動に失敗している。これを解決するにはコンテナがephemeralポートで起動するようするしないといけない。</p>

<p><a href="https://stackoverflow.com/questions/48931823/i-cant-deploy-a-new-container-to-my-ecs-cluster-because-of-ports-in-use">このSO</a>を読むと<a href="https://aws.amazon.com/jp/premiumsupport/knowledge-center/dynamic-port-mapping-ecs/">動的ポートマッピング</a>が必要でそれをするためにはLBを作成する必要があるらしい。</p>

<p>というわけで、一旦ECSの画面から離れてEC2のLoad Balancingのページに行く。Create Load BalancerからApplication Load Balancerを選択。ListenersのところでLoad Balancer ProtocolにHTTPを、Load Balancer Portは80 (nginxの待ち受けポート)を設定する。VPCはCluster作成の時に選択したVPCと同じものを選択。</p>

<p>次にConfigure Security GroupsでSecurity Groupを設定するんだけどここでも一つ重要ポイントが。</p>

<p><strong>選択したSGでTCPの0-65535ポートを許可しないとLBからトラフィックがコンテナまで到達しないのでタスクがちゃんと起動してくれない。</strong> これは<a href="https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/create-application-load-balancer.html#alb-configure-security-groups">公式のドキュメント</a>にも書かれているので忘れずに実施。</p>

<p>最後にTargetを登録する。うまくいけばClusterを作成した時に立ち上がったECSインスタンスが表示されるはず(されない場合は間違ったVPCを選んでいる？)なのでこれを選択する。これでLBの設定は完了。</p>

<h2 id="serviceの作成">Serviceの作成</h2>

<p>LBが無事できたらようやくServiceを作成できる。事前に作成したClusterを選択するとServicesというタブがあるのでそこから新しいServiceを作成していく。</p>

<ul>
  <li>Launch Type: <code class="language-plaintext highlighter-rouge">EC2</code> (Fargateよくわからん)</li>
  <li>Task Definition: Familyに最初に作成したTaskを選択する。ここでは <code class="language-plaintext highlighter-rouge">kim-app-nginx</code> 。RevisionというのがあるけどこれはTaskをアップデートした時のバージョニングとして使われる。</li>
  <li>Service name: TaskのFamilyと同じにしておくとCircleCI Orbs側で渡すパラメーターが少なくて少し楽になる。今回はTaskと合わせて <code class="language-plaintext highlighter-rouge">kim-app-nginx</code> とする。</li>
  <li>Number Tasks: 今回は常時ひとつだけタスクが稼働しているようにするので <code class="language-plaintext highlighter-rouge">1</code> と設定。</li>
</ul>

<p>Minimum healthy percentとMaximum healthy percentに関しては自動デプロイと絡んで重要なので解説する。この2つの設定は起動するタスクの最低・最大数を設定する。実際の数は <code class="language-plaintext highlighter-rouge">Number Tasks * percent</code> で算出。Minで設定した数だけ常時タスクが起動して、デプロイした時にMaxで設定した数になるように旧・新タスクが平行稼働する。(新タスクが完全にデプロイされたらMinの数にまた収束する)</p>

<p>今回はNumber Tasks 1、Min 100、Max 200にする。こうすると常時1タスクが起動していて、デプロイした時は旧・新合わせて2つのタスクが起動することでローリングアップデートすることができるようになる。</p>

<p>これらを設定してNext StepをクリックするとLoad balancingが出てくるので、Application Load Balancerを選ぶ。すると、さっき作成したLBが出てくるので選択する。 <strong>もう一度言うけど、これをしないと自動デプロイできないので必ず先にLBを作成しましょう。</strong></p>

<p>次にContainer to load balanceのところでAdd to load balancerを押すと確かnginxのコンテナが表示されるはずなので、Production listener port*に80を指定。Health check pathにはちゃんとコンテナが成功レスポンスを返すパスを指定することに注意。Service discoveryは今回必要ないので無効化にすればServiceの作成は完了。</p>

<h1 id="aws側のまとめ">AWS側のまとめ</h1>

<p>ここまででAWS側の設定は全部完了した。まとめると、ECRでリポジトリを作って、ECS側でTask, Service, Clusterと自動デプロイのためにLBも作成した。LBのURLにアクセスすればnginxのレスポンスが見えるはず。</p>

<h1 id="circleciの設定">CircleCIの設定</h1>

<p>これでようやくCircleCIの設定をすることができる。ただ、AWSに比べれば作業量ははるかに少ない。</p>

<h2 id="環境変数の設定">環境変数の設定</h2>

<p>センシティブな情報をconfig.ymlに直接書いてはまずいので環境変数に入れる。今回設定する環境変数は以下。</p>

<p><strong>AWS_ACCESS_KEY_ID</strong>
AWSのアクセスキー</p>

<p><strong>AWS_SECRET_ACCESS_KEY</strong>
AWSのシークレットキー</p>

<p><strong>AWS_ECR_ACCOUNT_URL</strong>
ECRのアカウントのURL。数字で始まって <code class="language-plaintext highlighter-rouge">amazonaws.com</code> で終わるところまで。今回の例だと <code class="language-plaintext highlighter-rouge">1234567.dkr.ecr.us-east-1.amazonaws.com</code> がそれにあたる。</p>

<p><strong>AWS_REGION</strong>
AWSのリージョン</p>

<p>これらの環境変数はOrbsのデフォルト値として設定されているので同じ名前の環境変数にすることに注意。</p>

<h1 id="aws-ecsaws-ecr-orbsを使う">aws-ecs/aws-ecr Orbsを使う</h1>

<p>記事が長くなってしまうので今回はOrbsそのものについては説明スキップ。すでに日本語で情報がたくさんあるのでそっちを見てください。以下の記事がおすすめ。</p>

<p>https://blog.tsub.me/post/introducing-to-circleci-orbs/</p>

<p>https://www.kaizenprogrammer.com/entry/2018/12/01/111145</p>

<p>https://github.com/sue445/circleci-user-community-meetup-01/blob/master/slides.md</p>

<p>今回は<a href="https://circleci.com/orbs/registry/orb/circleci/aws-ecs">aws-ecs</a>と<a href="https://circleci.com/orbs/registry/orb/circleci/aws-ecr">aws-ecr</a>というCircleCI自身がメンテしている公認Orbsを使う。</p>

<p>まずは <code class="language-plaintext highlighter-rouge">.circleci/config.yml</code> の完成系を貼っておく。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: 2.1
orbs:
  aws-ecr: circleci/aws-ecr@1.0.0 #(1)
  aws-ecs: circleci/aws-ecs@0.0.6 #(2)
workflows:
  build-and-deploy:
    jobs:
      - aws-ecr/build_and_push_image: #(3)
          account-url: AWS_ECR_ACCOUNT_URL
          repo: 'nginx'
          tag: '${CIRCLE_SHA1}'

      - aws-ecs/deploy-service-update: #(4)
                requires:
                  - aws-ecr/build_and_push_image
                family: 'kim-app-nginx'
                cluster-name: 'default-kim5'
                container-image-name-updates: 'container=nginx,image-and-tag=${AWS_ECR_ACCOUNT_URL}/nginx:${CIRCLE_SHA1}'
</code></pre></div></div>

<p><strong>(1):</strong> aws-ecr Orbをインポート</p>

<p><strong>(2):</strong> aws-ecs Orbをインポート</p>

<p><strong>(3):</strong> aws-ecrのOrbに <code class="language-plaintext highlighter-rouge">build_and_push_image</code> というジョブがあらかじめ用意されていてユーザーはこれに必要なパラメータを渡すだけでECRにデプロイできる。注意点としては <code class="language-plaintext highlighter-rouge">tag</code> のところで <code class="language-plaintext highlighter-rouge">${CIRCLE_SHA1}</code> をつかっている。これにはGitのコミットのSHAが入っているのでデプロイするたびに新しいタグが自動的につく。</p>

<p><strong>(4):</strong> 同じくaws-ecsに事前定義されている <code class="language-plaintext highlighter-rouge">build_and_push_image</code> というジョブにパラメーターを渡すだけでECSにデプロイできる。超便利。 <code class="language-plaintext highlighter-rouge">family</code> にはTaskの名前を指定。 <code class="language-plaintext highlighter-rouge">container-image-name-updates</code> にはアップデートするタスクのコンテナ名と使うイメージをカンマ区切りで渡す。重要なのは <code class="language-plaintext highlighter-rouge">image-and-tag</code> のところで <code class="language-plaintext highlighter-rouge">${CIRCLE_SHA1}</code> をタグとしてつかうことで <code class="language-plaintext highlighter-rouge">build_and_push_image</code> でデプロイしたイメージを使っている。</p>

<h1 id="circleciまとめ">CircleCIまとめ</h1>

<p>これ以降はプッシュするたびに <code class="language-plaintext highlighter-rouge">build_and_push_image</code> で新しいイメージがECRへプッシュされ <code class="language-plaintext highlighter-rouge">deploy-service-update</code> がそのイメージを使った新しいTaskを生成してServiceでそのタスクを使うようにアップートしてくれる。すると、ECSとLoad Balancerが連携して新しいインスタンスを作って古いインスタンスをDrainすることでローリングアップデート完了！</p>

<p><img src="/assets/lb_draining.png" alt="rolling_update" /></p>

<p>登壇したスライドでも書いたんだけど、Orbsを使うことで <code class="language-plaintext highlighter-rouge">config.yml</code> を370行から20行まで圧縮できたのでOrbsの便利さが実感できる例になった。</p>

<h1 id="全体まとめ">全体まとめ</h1>

<ul>
  <li>ECRとECSの設定はわりと簡単</li>
  <li>だけど、自動デプロイするにはLBが必要で少し手間が必要</li>
  <li>aws-ecs/aws-ecrのOrbsは超便利。これなしでスクラッチからconfig.ymlを書くとか吐き気がする。</li>
</ul>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[モチベーション]]></summary></entry><entry><title type="html">デブサミ2019のプレゼン作りの振り返り</title><link href="/blog/my-best-practice-presentation/" rel="alternate" type="text/html" title="デブサミ2019のプレゼン作りの振り返り" /><published>2019-02-18T14:55:00+09:00</published><updated>2019-02-18T14:55:00+09:00</updated><id>/blog/my-best-practice-presentation</id><content type="html" xml:base="/blog/my-best-practice-presentation/"><![CDATA[<h1 id="イントロ">イントロ</h1>

<p>デブサミ2019に登壇した時のプレゼンを今までにないくらい時間かけてしっかり作った。理由は2つあって、1つは会社が大金を払って参加した機会なのでスリルと引き換えに給料分の仕事をしてやろうと思ったこと。
もう一つは今自分の持てる限りで一度やってみることで、次回からのベースラインを作りたかったこと。</p>

<p>実際に発表したプレゼンは<a href="https://speakerdeck.com/kimh/cdwoshi-idao-siteshu-duan-shang-falsesohutoueakai-fa-wosiyou">ここ</a></p>

<h1 id="注意した点">注意した点</h1>

<h2 id="アウトラインを作り込む">アウトラインを作り込む</h2>

<p>プレゼンのアウトラインをDropbox Paper上でしっかり時間をかけて書いた。ここで何度も書いたり消したりして最終的にスライドへそのままコピペできるくらいまで内容を磨いた。</p>

<h2 id="第３者のフィードバックをもらう">第３者のフィードバックをもらう</h2>

<p>アウトラインがだいたいできた時点で、自分から結構絞り出したので途中からこれ以上でない、という状態になってしまった。そこで第３者のフィードバックを得て新しい視点を得ることする。たまたま友人がtwadaこと和田さんを知っていたので紹介してもらって
雑談込みで昼ごはんを食べに行くことに。和田さんは2018年デブサミでベストスピーカー賞を獲得していてかつテストの第一人者なので彼の意見はめちゃくちゃ役にたった。和田さんのおかげでもっとアウトラインを掘り下げることができた。
あと関係ないけど、キックボードをすごく気に入ってくれてあれがあるおかげで簡単に打ち解けることができた気がする。やはりキックボードの吸引力はハンパない。</p>

<h2 id="スライドを作り始める">スライドを作り始める</h2>

<p>この時点でやっとスライドを作り始める。昔はいきなりスライドを作ってしまうことが多かったけど、内容が固まってない時点でスライド作りすると色々他のことが気になって（フォントサイズや入れる画像とか）内容がおろそかになってしまうのでこれはやめたほうがいい。
アウトラインをしっかりつくっているので基本この時点ではほとんどPaperからのコピペで完了。</p>

<h2 id="もう一度第３者のフィードバックをもらう">もう一度第３者のフィードバックをもらう</h2>

<p>スライドも一応できたのでここで再度フィードバックをもらうためにコミュニティー活動でお世話になっている小島さんにみてもらう。大体大丈夫だと思ってみてもらったけど後半まで見てもらうことができないくらいフィードバックがあり軽くあせる。
もっとも問題だったのは、オーディエンスのことを考え抜けていない。きっとCI/CDのことを知らない人も一定数聞きにくるけど、今の内容だとその人たちを置いてけぼりにしてしまう。
問題意識に対する同意がない!(なぜそれが問題なのかを説得しきれていない)、用語が揺らいでいる!、内容がジャンプしまくっている！、ゴラーーー！っていう感じでレビュー終了。自分だと当たり前のことを当然他人はそう思ってくれないことを改めて認識する。
あとスライドは確かにひどかった。説明でカバーすればいいと思ってたからスライドをおろそかにしてのも問題だった。あとでspeakerdeckとかで見た人がわかるようためにもしっかりスライドも作らないといけないことを反省。</p>

<h2 id="練習">練習</h2>

<p>今までほとんど練習なしでプレゼン当日に望んでいたけど元から口がうまいことほうじゃないし、それじゃーうまくできるわけないわな、ということで今回は一人プレゼンもしっかりやった。時間をはかりながら何度もしゃべって自分に一番フィットする説明の仕方を
各スライドで探っていき、それをそのままスピーカーノートに書いていく。ここで学んだことは、何回練習しても詰まる部分は余計なスライドだということ。結局自分がしっかり理解してないからつまるのであって、理解していないのなら説明するべきではない。
練習の時点をこうゆうスライドを全部削った。これにより全体のしゃべりが滑らかになって、このdelete作業はかなり重要だったと思う。</p>

<h2 id="本番">本番</h2>

<p>あとはやるだけ。しっかり準備したのでいい感じの緊張で本番に臨ことができた。その場の空気の緊張感がいい感じにアドリブを作ってくれて練習の時よりも上手にしゃべることができた。</p>

<h1 id="ふりかえり">ふりかえり</h1>

<p>オーディエンスの設定とそれに合わせた内容をできたんじゃないかと思う。このツイートは自分のやったことが無駄じゃないと思えたのですごく嬉しかった。がんばったかいがあった！</p>

<p><img src="/assets/devsumi_tweet.png" alt="devsumi_tweet" /></p>

<p>https://twitter.com/devvosa/status/1096407370240909312</p>

<p>以下は反省とやり残したところ。</p>

<ul>
  <li>フィードバックをもっと早い時点でもらう</li>
  <li>スライドの質をあげる。どんなスライドが見やすいのかとかが未だにピンとこない</li>
  <li>しゃべりのテクニックについては全く勉強する時間がなかった</li>
  <li>他の人のプレゼンを見ていいプレゼンについて学ぶ</li>
</ul>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[イントロ]]></summary></entry><entry><title type="html">2018 Review</title><link href="/blog/2018-review/" rel="alternate" type="text/html" title="2018 Review" /><published>2018-12-31T14:25:00+09:00</published><updated>2018-12-31T14:25:00+09:00</updated><id>/blog/2018-review</id><content type="html" xml:base="/blog/2018-review/"><![CDATA[<h1 id="summary">Summary</h1>

<p>2018年は充実した年だった。二人目の子供の誕生、CircleCI Japanの立ち上げ、電動キックボードとの出会い、など人生に大きな影響を与えるイベントが目白押しの一年だった。</p>

<h1 id="works">Works</h1>

<p>やはり一番大きいのは6月のCircleCI Japanの立ち上げがある。CircleCIに入った時は考えもしなかったJapanオフィスがこんなにも早く立ち上がるとは。すでにCircleCIという素晴らしいプロダクトがあるので”強くてニューゲーム”のようでチートっぽいけどスタートアップの立ち上げはとてもいい経験となった。この半年で本当にたくさんの新しいことができた。(というかまだ半年か！)</p>

<ul>
  <li>チームメンバーのHiring</li>
  <li>CodeZineでの連載寄稿</li>
  <li>ポッドキャスト収録</li>
  <li>マーケティングの勉強</li>
  <li>ローカライゼーション</li>
  <li>たくさんの人との出会い</li>
</ul>

<p>次に大きなイベントは3月の出張先での電動キックボードとの出会い。最初に電動キックボードに乗った時、ハンマーで脳みそを叩かれるような衝撃を今でもよく覚えている。僕はこのユーザー体験をなんとしても日本でも広めたい。そのためにこの９ヶ月間で以下に注力してきた。</p>

<ul>
  <li>電動キックボードに関連する法律の調査と理解</li>
  <li>その法律を遵守するための現実解の模索</li>
  <li>ビジネスモデルの構築</li>
</ul>

<p>2018年は選択肢を広げるために色々なアイデアをあえてふわふわした形でキープしておいた。2019年はこのアイデアを一気に凝縮して実際にサービスを立ち上げるのが目標。世界的に見ると日本は電動キックボードビジネスの真空地帯なんだけど、それでも最近少しずつ競合が出てきているのであんまりゆっくりもしていられない。</p>

<h1 id="money">Money</h1>

<p>今年はやることなすこと裏目に出るひどい年だった。具体的には原油先物、トルコリラ、日経平均ベアでぼろ負けた。敗因は世界経済の先行きに過度に悲観的になりすぎたこと。全ての判断が半年早く、もう少しこらえていれば挽回するチャンスがあっただけにとても残念だ。ただ、日経平均ベアはこれから自分の予想したように動きそうなので2019年に期待したい。</p>

<h1 id="family">Family</h1>

<p>なんといっても大きなイベントは二人目の男の子の誕生。もしかしたら子供ができないと思った時期からすれば健康な男の子を二人も授かったのは奇跡のよう。名前は”哲斗”と言う。僕が尊敬する気象学者の<a href="https://en.wikipedia.org/wiki/Ted_Fujita">藤田 Ted・哲也</a>からいただいた。新生児の育児はどうしても奥さんの負担が大きくなってしまうので、もう少し落ち着いたら奥さんにも安心して買い物とか温泉とかいけるように下の子の育児にも貢献していきたい。</p>

<p>上の子ももうすぐ３歳になる。残念ながら僕の気が小さいところや引っ込み思案な性格をしっかり受け継いでしまっているんだけど、それを自分でもなんとか克服しようとしているのが日々の成長でわかるのが嬉しい。英語も日本語の７割くらいでしゃべれるようになっているみたいで子供の学習能力には感服する。</p>

<h1 id="sad-things">Sad Things</h1>
<ul>
  <li>妻方のおばあさんが二人他界したこと。特に僕はそのうちの一人のおばあさんが大好きだったので(向こうも好きでいてくれたと思う)本当に悲しい。もう少し何か喜ばしてあげることができたんじゃないかといつも考えてしまう。</li>
  <li>日本経済がどう考えても破滅(に近い)の道を突き進んでいること。そして、それを問題視する人があまりにも少ないということ。本当に日本人というのは問題を見て見ぬ振りをするのが得意らしい。</li>
  <li>Mahmood AliがCircleCIを去ったこと。彼には本当にお世話になったし、たくさんのことを学んだ。もっと一緒に仕事がしたかった。</li>
</ul>

<h1 id="big-ideas">Big Ideas</h1>
<ul>
  <li>脳は大きく変わるということ。これは比喩でなく、成功体験やトレーニングで筋肉のように物理的構造が変わる。これは生まれつきの性格を変えることもできるということなので、子供と一緒に実践していきたい。</li>
  <li>ルールの外側、最強。電動キックボードを原付化している時にこのアイデアを得た。警察に怒られないために電動キックボードを原付化してルールを守ろうとすると、行動はそのルール内で制限されてしまい逆にちょっとルールを破っただけで怒られるようになってしまう。反対に素の電動キックボードには現在適用できるルールがないので大抵のことは注意で済まされる。だれもトランプ大統領の勢いを止めることができないのは彼がルールの外側で行動しているからだと思う。</li>
  <li>アウトプットファーストの重要性。上手にアウトプットすることで周りに影響を与えてさらにアウトプットするといういい循環ができる。</li>
</ul>

<h1 id="good-books">Good Books</h1>

<p>今年は忙しくてあんまり読めなかったけど、まーそれでも気にいった本はいくつかあった。しかし、プログラミング系の本が少ない…</p>

<ul>
  <li><a href="https://www.amazon.co.jp/gp/product/B01GJOQSO2/ref=oh_aui_d_detailpage_o06_?ie=UTF8&amp;psc=1">意識はいつ生まれるのか - 脳の謎に挑む統合情報理論</a></li>
  <li><a href="https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B7%9A%E5%BD%A2%E4%BB%A3%E6%95%B0-%E5%B9%B3%E5%B2%A1-%E5%92%8C%E5%B9%B8/dp/4274065782">プログラミングのための線形代数</a></li>
  <li><a href="https://www.amazon.co.jp/The-Whole-Brain-Child/dp/1491514817/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1546232408&amp;sr=1-2&amp;keywords=whole+brain+child">The Whole-Brain Child</a></li>
  <li><a href="https://www.amazon.co.jp/%E3%83%9B%E3%83%A2%E3%83%BB%E3%83%87%E3%82%A6%E3%82%B9-%E4%B8%8A-%E3%83%86%E3%82%AF%E3%83%8E%E3%83%AD%E3%82%B8%E3%83%BC%E3%81%A8%E3%82%B5%E3%83%94%E3%82%A8%E3%83%B3%E3%82%B9%E3%81%AE%E6%9C%AA%E6%9D%A5-%E3%83%A6%E3%83%B4%E3%82%A1%E3%83%AB%E3%83%BB%E3%83%8E%E3%82%A2%E3%83%BB%E3%83%8F%E3%83%A9%E3%83%AA/dp/4309227368/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1546232441&amp;sr=1-1&amp;keywords=%E3%83%9B%E3%83%A2%E3%83%87%E3%82%A6%E3%82%B9">ホモ・デウス</a></li>
  <li><a href="https://www.amazon.co.jp/%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA%E3%83%A9%E3%83%9C%E2%80%95%E2%80%95%E3%80%8C%E3%81%82%E3%81%A3%E3%81%9F%E3%82%89%E3%81%84%E3%81%84%E3%81%AA%E3%80%8D%E3%82%92%E3%81%8B%E3%81%9F%E3%81%A1%E3%81%AB%E3%81%99%E3%82%8B%E3%80%8C%E3%81%B2%E3%82%89%E3%82%81%E3%81%8D%E3%80%8D%E3%81%AE%E6%8A%80%E8%A1%93-%E4%BD%90%E8%97%A4-%E3%82%AA%E3%82%AA%E3%82%AD/dp/4478028923/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1546232527&amp;sr=1-1&amp;keywords=%E4%BD%90%E8%97%A4%E3%82%AA%E3%82%AA%E3%82%AD">問題解決ラボ――「あったらいいな」をかたちにする「ひらめき」の技術</a></li>
</ul>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[Summary]]></summary></entry><entry><title type="html">Regex Notes</title><link href="/blog/regex-notes/" rel="alternate" type="text/html" title="Regex Notes" /><published>2018-02-01T22:01:00+09:00</published><updated>2018-02-01T22:01:00+09:00</updated><id>/blog/regex-notes</id><content type="html" xml:base="/blog/regex-notes/"><![CDATA[<h2 id="基本動作">基本動作</h2>

<ul>
  <li>Regex Engine</li>
  <li>Regexデータ</li>
  <li>文字列データ</li>
</ul>

<p>この三つがメインでEngineがRegexデータと文字列データをひとつずつチェックしていく。<strong>マッチ</strong>というのはRegex全体で表現されるパターンが全体でマッチしている場合のことをいう。(ただ各Regexがマッチしている場合もマッチともいう)。わかりづらいので各Regexがマッチしていることは成功といいダメな時は失敗と呼ぶ。</p>

<p>以下はもっとも基本なマッチ。</p>

<h2 id="regex基本原則">Regex基本原則</h2>

<p>まずはRegexの基本原則を見てみる。しかし、これらの基本原則はオプションによって変化して、場合ごとに考え方を変えないといけないところにRegexの難しがあると思う。ただ、基本原則をしっかり理解しておけば、変化系にも対応しやすくなる。</p>

<h3 id="左から一文字ずつマッチしていく">左から一文字ずつマッチしていく</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ab/
ab
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"ab"</code>にマッチした。</li>
</ol>

<p>Regex EngineはRegexデータ、文字列ともに現在のステップのポジションを覚えていて、ステップ毎にそれらのポジションをひとつずつずらしていく。ポジションは左から右に動いていく。</p>

<h3 id="マッチした時点で終了">マッチした時点で終了</h3>

<p>マッチが達成されたら、それ以降の文字列は無視する。これを貪欲でないマッチとか一般的には呼ぶが自分にはどうもわかりずらい。代わりに<strong>せっかちマッチ</strong>と覚えている。せっかちなので一度マッチした時点で<strong>マッチしたよ！</strong>と言って仕事を終わってしまう。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ab/
abab
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>主なEngineではデフォルトではLazy、つまりマッチが成功した時点で終わる</li>
  <li>終了</li>
  <li>結果: 最初の<code class="language-plaintext highlighter-rouge">"ab"</code>だけにマッチした。</li>
</ol>

<h3 id="マッチが成功するために全ての可能性を試す">マッチが成功するために全ての可能性を試す</h3>

<p>Regexにとって一番大事な仕事はマッチする文字列を探すこと。それを達成するためにRegexは全ての可能性を試す。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ab/
acab
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"c"</code> =&gt; 失敗</li>
  <li>失敗したのでRegexの最初に戻ってマッチさせようとする。これをBacktrackと呼ぶ。Backtrack == 巻き戻し と考えればいい</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"ab"</code>にマッチした。</li>
</ol>

<h2 id="よく使われる応用regex">よく使われる応用Regex</h2>

<p>ここからは実際によく使うRegexを紹介。中には基本原則で紹介した動作を変えるものもあるので、場合ごとに動作がどう変わるかを把握しないといけない。</p>

<h3 id="g-を使うと一度マッチしても続けてマッチさせようとする貪欲マッチ">g を使うと一度マッチしても続けてマッチさせようとする（貪欲マッチ)</h3>

<p>Regexの最後に <code class="language-plaintext highlighter-rouge">g</code> をつけると一度マッチしても終了せず続けてマッチさせようとする。<code class="language-plaintext highlighter-rouge">g</code>を修飾子と呼びこの動作を貪欲マッチと呼ぶ。せっかちマッチの場合と同じでわかりにくいので<strong>熱心マッチ</strong>と覚える。これは基本動作のせっかちマッチを変える。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ab/g
abab
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>熱心モードなので文字列がある残っている以上つづける。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"abab"</code>にマッチした。</li>
</ol>

<h3 id="文字だけじゃなくその位置を含めて成功失敗を判定アンカー">文字だけじゃなくその位置を含めて成功/失敗を判定（アンカー）</h3>

<p>今まで見てきたRegexは同じ文字かどうかを判定するものだった。例えば、<code class="language-plaintext highlighter-rouge">/ab/</code>はaのあとにbが続く<code class="language-plaintext highlighter-rouge">"ab"</code>にマッチする。言い換えれば、aのあとにbが続く限りそれがどこにあろうがマッチする。だから<code class="language-plaintext highlighter-rouge">"1ab2</code>はこの場合マッチする。</p>

<p><code class="language-plaintext highlighter-rouge">^</code>と<code class="language-plaintext highlighter-rouge">$</code>がRegexの前につくと文字のマッチだけじゃなくその文字がある位置まで見る。こうゆう種類のRegexをアンカーと呼ぶ。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/^a/
1a
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 失敗</li>
  <li>BacktrackでRegexが最初に戻る。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 失敗</li>
  <li><code class="language-plaintext highlighter-rouge">"a"</code>にはマッチしているが <code class="language-plaintext highlighter-rouge">^a</code>は一番最初にある<code class="language-plaintext highlighter-rouge">"a"</code>なので失敗。</li>
  <li>終了</li>
  <li>結果: マッチなし</li>
</ol>

<h3 id="改行直後の文字は最初の文字列ではない">改行直後の文字は最初の文字列ではない</h3>

<p><code class="language-plaintext highlighter-rouge">^</code>は文字列の最初の位置にマッチするが、改行直後の文字列は最初の文字とはならない。この動作が主なRegexエンジンのデフォルト。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/^a/

# 複数行に渡る文字列
1a
a


</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 失敗</li>
  <li>BacktrackでRegexが最初に戻る。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 失敗</li>
  <li>BacktrackでRegexが最初に戻る。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 失敗</li>
  <li><code class="language-plaintext highlighter-rouge">^a</code>はあくまで文字列全体の最初にある<code class="language-plaintext highlighter-rouge">"a"</code>。二つ目の<code class="language-plaintext highlighter-rouge">"a"</code>は行の最初のaだが文字列全体の最初ではないのでマッチしない。</li>
  <li>終了</li>
  <li>結果: マッチなし</li>
</ol>

<h3 id="mを使うと改行が入っていても最初の文字とみなす">mを使うと改行が入っていても最初の文字とみなす</h3>

<p>上で例だと改行直後、二つ目の<code class="language-plaintext highlighter-rouge">"a"</code>は<code class="language-plaintext highlighter-rouge">/^a/</code>にはマッチしなかった。これをマッチさせるには<code class="language-plaintext highlighter-rouge">m</code>修飾子を使う。すると、改行直後の文字でも文字列の最初とみなされる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/^a/m

# 複数行に渡る文字列
1a
a
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 失敗</li>
  <li>BacktrackでRegexが最初に戻る。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">^a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li><code class="language-plaintext highlighter-rouge">m</code>修飾子があるので改行直後の<code class="language-plaintext highlighter-rouge">"a"</code>は文字列の最初とみなされる。</li>
  <li>終了</li>
  <li>結果: 二つ目の<code class="language-plaintext highlighter-rouge">a</code>にマッチ</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">m</code>を使った時の動作をmulti-lineモードと呼ぶ。</p>

<h3 id="ほぼどんな文字にもマッチする--ドット">（ほぼ）どんな文字にもマッチする . (ドット)</h3>

<p>どんな文字にでもマッチするRegexに<code class="language-plaintext highlighter-rouge">.</code>がある。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.../
1&amp;!
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"&amp;"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"!"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">1&amp;!</code>にマッチ</li>
</ol>

<p>しかし<code class="language-plaintext highlighter-rouge">.</code>にも例外はあり改行にはマッチしない。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.../
# 複数行に渡る文字列
1
2
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">\n</code>  =&gt; 失敗</li>
  <li>Backtrackで最初の <code class="language-plaintext highlighter-rouge">.</code>に戻る</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"2"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">\n</code>  =&gt; 失敗</li>
  <li>終了</li>
  <li>結果: マッチなし</li>
</ol>

<h3 id="s-を使うと--ドットが改行にもマッチする">s を使うと . (ドット)が改行にもマッチする</h3>

<p><code class="language-plaintext highlighter-rouge">s</code>修飾子を使うと<code class="language-plaintext highlighter-rouge">.</code>が改行にもマッチするようになる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.../s
# 複数行に渡る文字列
1
2
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"1"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">\n</code>  =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.</code> 文字列: <code class="language-plaintext highlighter-rouge">"2"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">1\n2</code>にマッチ</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">s</code>を使った時の動作をsingle-lineモードと呼ぶ。注意するのは single-modeとmulti-lineモードは全く別物だということ。single-lineモードは<code class="language-plaintext highlighter-rouge">.</code>が改行も含むようにすることに対して、multi-lineモードはアンカー (<code class="language-plaintext highlighter-rouge">^</code>や<code class="language-plaintext highlighter-rouge">&amp;</code>)が改行を考慮するするようにすることなので、single-lineとmulti-lineは相反するモードではない。（両方指定可能)</p>

<h3 id="パターンを繰り返す">パターンを繰り返す</h3>

<p><code class="language-plaintext highlighter-rouge">+</code>や<code class="language-plaintext highlighter-rouge">*</code>を使うとその直前のRegexを繰り返してマッチするようにできる。<code class="language-plaintext highlighter-rouge">+</code>は直前のRegexの一回以上の繰り返し。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/a+/
aaa
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a+</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a+</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a+</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"aaa"</code>にマッチ</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">*</code>は直前のRegexの0回以上に繰り返し。つまりマッチする文字がなくても成功になる。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/a*b/
b
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a*</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li><code class="language-plaintext highlighter-rouge">*</code>は0回以上のaの繰り返せば成功、つまりaがなくても成功とみなす。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"b"</code>にマッチ</li>
</ol>

<h3 id="regexの最後に行く前に文字が終わってしまったら文字を戻す">Regexの最後に行く前に文字が終わってしまったら文字を戻す</h3>

<p><code class="language-plaintext highlighter-rouge">.</code>と<code class="language-plaintext highlighter-rouge">+</code>や<code class="language-plaintext highlighter-rouge">*</code>を組み合わせると任意の文字の無限の繰り返しを指定できるので文字列のほうが先に終わってしまうことがある。Regexが失敗したときはBacktrackして次の文字からまたやり直したが繰り返しを使うと文字の方を巻き戻す。普通のBacktrackと区別するために文字列Backtrackと呼ぶ。Regexがこうゆう動きをするのは、最初に書いた<strong>マッチが成功するために全ての可能性を試す</strong>という基本原則があるから。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/a.+b/
aab
</code></pre></div></div>
<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.+</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li><code class="language-plaintext highlighter-rouge">.+</code>は任意の文字の繰り返しなので次のRegexには進まない。</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">.+</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>この時点で文字列が終わってしまったが、Regex側は<code class="language-plaintext highlighter-rouge">b</code>がまだ残っている。<code class="language-plaintext highlighter-rouge">b</code>まで成功しないとマッチではない。</li>
  <li>文字列をマッチするとわかっているところまでBacktrackする(この場合最初の<code class="language-plaintext highlighter-rouge">"aa"</code>が<code class="language-plaintext highlighter-rouge">/a.+/</code>でマッチするとわかっているのでここまで戻す。）</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">b</code> 文字列: <code class="language-plaintext highlighter-rouge">"b"</code>=&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"aab"</code>にマッチ</li>
</ol>

<h2 id="もし--ならマッチを試みる">もし ~ ならマッチを試みる</h2>

<p>ここまで紹介したRegexではプログラミングでつかう<code class="language-plaintext highlighter-rouge">IF ~ then ~ END</code>のようなことはできない。それをできるようにするのがLookahead。重要なポイントはLookaheadは条件をしていしるだけなのでそれ自体はマッチの結果には含まれない。</p>

<h3 id="もしxにyがつづけばマッチ-positive-lookahead">もしXにYがつづけばマッチ (Positive Lookahead)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/a(?=b)/
abd
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">a</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">(?=b)</code>の<code class="language-plaintext highlighter-rouge">b</code>の部分 文字列: <code class="language-plaintext highlighter-rouge">"b"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">(?=b)</code>の<code class="language-plaintext highlighter-rouge">?=</code>の部分 上のステップで<code class="language-plaintext highlighter-rouge">b</code>がマッチしたら成功 =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"a"</code>にマッチ。<strong>bはあくまで条件なのでb自体にはマッチしない</strong></li>
</ol>

<p>この例ではあまり意味があるように思えないがLookaheadはXが続かないYを探す時に真価を発揮する。</p>

<h3 id="もしxにyがつづかなければマッチ-negative-lookahead">もしXにYがつづかなければマッチ (Negative Lookahead)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q(?!u)
aq
</code></pre></div></div>

<ol>
  <li>Regex: <code class="language-plaintext highlighter-rouge">q</code> 文字列: <code class="language-plaintext highlighter-rouge">"a"</code> =&gt; 失敗</li>
  <li>Backtrack</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">q</code> 文字列: <code class="language-plaintext highlighter-rouge">"q"</code> =&gt; 成功</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">(?!=u)</code>の<code class="language-plaintext highlighter-rouge">u</code>の部分 文字列: <code class="language-plaintext highlighter-rouge">"u"</code> =&gt; 失敗</li>
  <li>Regex: <code class="language-plaintext highlighter-rouge">(?!u)</code>の<code class="language-plaintext highlighter-rouge">?!</code>の部分 上のステップで<code class="language-plaintext highlighter-rouge">u</code>がマッチしていないから成功 =&gt; 成功</li>
  <li>終了</li>
  <li>結果: <code class="language-plaintext highlighter-rouge">"q"</code>にマッチ</li>
</ol>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[基本動作]]></summary></entry><entry><title type="html">CollageとAnimationを使ってElmでアプリを作る</title><link href="/blog/make-elm-app/" rel="alternate" type="text/html" title="CollageとAnimationを使ってElmでアプリを作る" /><published>2017-12-11T21:48:00+09:00</published><updated>2017-12-11T21:48:00+09:00</updated><id>/blog/make-elm-app</id><content type="html" xml:base="/blog/make-elm-app/"><![CDATA[<p>この記事はQiita Elm Adventcalendar 2017に投稿した記事です。</p>

<h2 id="最初に">最初に</h2>

<p>Functional Reactive Programmingを調べていて偶然Elmに出会いました。最新版のElm0.18ではElmはFRPの概念を完全に取り払いFRPとは関係なくなりましたが、
実際にElmを触ってみるとどんどんその面白さに引き込まれて行きました。もっとElmで何か作りたくなったので自分の子供が遊べるようなToy Appを作ることにしました。 このアプリを作る際にはまった点や大事な点をできるだけ丁寧に解説してみたいと思います。</p>

<h2 id="この記事の対象者">この記事の対象者</h2>

<p>この記事ではElmについての基本知識があることを前提としています。Elmにはすでに素晴らしいチュートリアルがあるのでまだElmに触ったことがなければ https://guide.elm-lang.org/ と https://www.elm-tutorial.org/en/ をお勧めします。
基本の文法はわかるけどいまいちSubscriptionやPortがわからないなーという人には楽しんでもらえると思います。</p>

<h2 id="airplane-toy-app">Airplane Toy App</h2>

<p>この記事で解説しているアプリは https://s3-ap-northeast-1.amazonaws.com/airplane-toy-app/index.html で公開しています。 (このアプリは音が出るので注意!!)
コードは https://github.com/kimh/kids-toy-apps で公開しています。
2歳になる自分の息子に作ったアプリなのでとても単純な仕様で、クリックした場所に飛行機がいかにも子供が好きそうな音を出して移動する、というだけのアプリです。
しかしElmで実際にアプリを作るのに必要なことはほとんど使う必要があったのでとても勉強になりました。</p>

<h2 id="イベントフロー">イベントフロー</h2>

<p>このアプリでは以下のようなイベントフローで構成されています。</p>

<p>ページをロード -&gt; Init関数が呼ばれModelが初期化される -&gt; ユーザー (うちの息子) が画面のどこかをクリックする -&gt; <code class="language-plaintext highlighter-rouge">MouseMsg</code>メッセージが送信される -&gt; Subscriptionを通じて、Update関数が呼ばれる。クリックされた座標を取得して、Modelにセットする。 -&gt; Modelに新しい座標がセットされると飛行機が動く -&gt; 同時に <code class="language-plaintext highlighter-rouge">PlaySound</code> メッセージが送信される -&gt; JavascriptにPortでメッセージを送信する -&gt; Javascript側で <code class="language-plaintext highlighter-rouge">audio</code> 要素の <code class="language-plaintext highlighter-rouge">play</code> メソッドを呼ぶ</p>

<h2 id="飛行機画像のレンダリング">飛行機画像のレンダリング</h2>

<p>飛行機の画像を扱うのに Elm Collageを使っています。Collageのライブラリには主にhttps://github.com/evancz/elm-graphics と https://github.com/timjs/elm-collage がありますが、後者です。timjs/elm-collageはevancz/elm-graphisを置き換えるものだと考えているのでこれからアプリを作るのならtimjs/elm-collageを使うことぼをお勧めします。</p>

<p>重要となるポイントを説明していきます。</p>

<p><code class="language-plaintext highlighter-rouge">image</code> で飛行機の画像ファイルを読み込んで <code class="language-plaintext highlighter-rouge">shift</code> で初期位置まで移動させます。 <code class="language-plaintext highlighter-rouge">pos</code> は 渡されたModelから作成します。(後述)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plane</span> <span class="o">=</span>
    <span class="n">image</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span> <span class="s">"images/airplane.svg"</span>
    <span class="o">|&gt;</span> <span class="n">shift</span> <span class="n">pos</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">spacer</code> を使っている部分は少しわかりにくいです。timjs/elm-collageでは座標が絶対的ではなく他の要素からの相対的なCollageの位置を指定するので
<code class="language-plaintext highlighter-rouge">plane</code> だけを <code class="language-plaintext highlighter-rouge">shift</code> しても画像が動いてくれませんでした。そこで <code class="language-plaintext highlighter-rouge">plane</code> の前に透明な要素である <code class="language-plaintext highlighter-rouge">spacer</code> を挟むことでうまく移動してくれるようにしました。（このあたりは自分の理解も曖昧なのでもっとうまい方法があるかも）<code class="language-plaintext highlighter-rouge">group</code> は複数のCollageを並べてくれる関数です。</p>

<p>コメントアウトしている <code class="language-plaintext highlighter-rouge">debug</code> は有効にするとCollageのボーダーとセンターを赤線で表示してくれるのでつまった時に便利なのでいつでも有効にできるように残しています。</p>

<p>最後に要素を <code class="language-plaintext highlighter-rouge">Html Msg</code> 型に <code class="language-plaintext highlighter-rouge">svg</code> で変換しています。このパターンはCollageではいつも使うパターンです。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">group</span> <span class="p">[</span>
  <span class="n">spacer</span> <span class="mi">300</span> <span class="mi">300</span><span class="p">,</span>
  <span class="n">plane</span>
<span class="p">]</span>
    <span class="c1">-- |&gt; Collage.Layout.debug</span>
    <span class="o">|</span> <span class="o">&gt;</span> <span class="n">svg</span> <span class="o">|</span>
</code></pre></div></div>

<h2 id="アニメーション">アニメーション</h2>

<p>飛行機を任意の場所に移動するために <code class="language-plaintext highlighter-rouge">elm-animation</code> を使っています。基本的な考え方はブラウザのフレーム更新毎に送られる <code class="language-plaintext highlighter-rouge">Tick</code> メッセージを捕まえてその中でモデルを更新します。</p>

<p>重要となるポイントを説明していきます。</p>

<p>モデルにはx座標、y座標、clockをもたせています。これらの値を <code class="language-plaintext highlighter-rouge">Tick</code> イベントの中で更新します。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="n">alias</span> <span class="kt">Model</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">Animation</span><span class="p">,</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">Animation</span><span class="p">,</span> <span class="n">clock</span> <span class="o">:</span> <span class="kt">Time</span> <span class="p">}</span>

<span class="n">model</span> <span class="o">:</span> <span class="kt">Model</span>
<span class="n">model</span> <span class="o">=</span>
    <span class="kt">Model</span>
        <span class="p">(</span><span class="n">animation</span> <span class="mi">0</span> <span class="o">|&gt;</span> <span class="n">duration</span> <span class="kt">Time</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="p">(</span><span class="n">animation</span> <span class="mi">0</span> <span class="o">|&gt;</span> <span class="n">duration</span> <span class="kt">Time</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
        <span class="mi">0</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Tick</code> メッセージは引数つきのメッセージで、引数にアニメーションの初期状態から差分の時刻が送られてきます。それをモデルの <code class="language-plaintext highlighter-rouge">clock</code> にセットしています。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">update</span> <span class="o">:</span> <span class="kt">Msg</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Model</span><span class="p">,</span> <span class="kt">Cmd</span> <span class="kt">Msg</span><span class="p">)</span>
<span class="n">update</span> <span class="n">msg</span> <span class="n">model</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">msg</span> <span class="kr">of</span>
        <span class="kt">Tick</span> <span class="n">dt</span> <span class="o">-&gt;</span>
            <span class="kr">let</span>
                <span class="n">clock</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">clock</span> <span class="o">+</span> <span class="n">dt</span>
            <span class="kr">in</span>
                <span class="p">({</span> <span class="n">model</span> <span class="o">|</span> <span class="n">clock</span> <span class="o">=</span> <span class="n">clock</span> <span class="p">},</span> <span class="kt">Cmd</span><span class="o">.</span><span class="n">none</span><span class="p">)</span>
</code></pre></div></div>

<p>更新されたclockの値と飛行機のx,y座標を <code class="language-plaintext highlighter-rouge">animate</code> に渡すとその時刻での飛行機の座標が返ってきます。 <code class="language-plaintext highlighter-rouge">shift pos</code> をするとその座標に画像がレンダリングされます。これを各 <code class="language-plaintext highlighter-rouge">Tick</code> 毎に行うことで画像が移動していくように見えます。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">view</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">clock</span> <span class="p">}</span> <span class="o">=</span>
    <span class="kr">let</span>
        <span class="n">pos</span> <span class="o">=</span>
            <span class="p">(</span> <span class="n">animate</span> <span class="n">clock</span> <span class="n">x</span><span class="p">,</span> <span class="n">animate</span> <span class="n">clock</span> <span class="n">y</span> <span class="p">)</span>

        <span class="n">plane</span> <span class="o">=</span>
            <span class="n">image</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span> <span class="s">"images/airplane.svg"</span>
            <span class="o">|&gt;</span> <span class="n">shift</span> <span class="n">pos</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Tick</code> メッセージはそのままでは送信されません。送信するためには <code class="language-plaintext highlighter-rouge">Subscription</code> で <code class="language-plaintext highlighter-rouge">animation-frame</code> という別のライブラリを使って <code class="language-plaintext highlighter-rouge">AnimationFrame.diffs Tick</code> を呼びます。Animationするためのライブラリ(<code class="language-plaintext highlighter-rouge">elm-animation</code>) とフレーム遷移を扱うライブラリが別なのは面白いポイントです。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span>
    <span class="kt">Sub</span><span class="o">.</span><span class="n">batch</span>
        <span class="p">[</span>
        <span class="kt">AnimationFrame</span><span class="o">.</span><span class="n">diffs</span> <span class="kt">Tick</span><span class="p">,</span>
        <span class="kt">Mouse</span><span class="o">.</span><span class="n">clicks</span> <span class="kt">MouseMsg</span>
        <span class="p">]</span>
</code></pre></div></div>

<h2 id="マウスイベント">マウスイベント</h2>

<p>クリックされた場所まで飛行機を移動しないといけないのでマウスイベントを捕まえてクリックされた座標を取得します。</p>

<p>まずマウスイベントを捕まえるために <code class="language-plaintext highlighter-rouge">Mouse.clicks MouseMsg</code> をサブスクライブします。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span>
    <span class="kt">Sub</span><span class="o">.</span><span class="n">batch</span>
        <span class="p">[</span>
        <span class="kt">AnimationFrame</span><span class="o">.</span><span class="n">diffs</span> <span class="kt">Tick</span><span class="p">,</span>
        <span class="kt">Mouse</span><span class="o">.</span><span class="n">clicks</span> <span class="kt">MouseMsg</span>
        <span class="p">]</span>
</code></pre></div></div>

<p>実際にマウスイベントを扱うには <code class="language-plaintext highlighter-rouge">MouseMsg</code> を捕まえます。<code class="language-plaintext highlighter-rouge">MouseMsg</code> は引数つきのメッセージで引数にはクリックされた座標が入っています。 このアプリ独自のロジックで <code class="language-plaintext highlighter-rouge">adjustment</code> とかを使っていますが、重要なのはクリックされた座標をFloat型に変換して <code class="language-plaintext highlighter-rouge">retarget</code> に渡すところです。<code class="language-plaintext highlighter-rouge">retarget</code> は画像がどこまで動くかの値 <code class="language-plaintext highlighter-rouge">to</code> を更新して座標で返すので、それをモデルの座標にセットします。こうすることでクリックされた位置が新しいアニメーションの <code class="language-plaintext highlighter-rouge">to</code> になります。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">MouseMsg</span> <span class="n">position</span> <span class="o">-&gt;</span>
   <span class="kr">let</span>
       <span class="c1">-- We need this so that plan's center moves to the new postion</span>
       <span class="n">adjustment</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span>
       <span class="n">posx</span> <span class="o">=</span> <span class="n">position</span><span class="o">.</span><span class="n">x</span>
              <span class="o">|&gt;</span> <span class="n">toFloat</span>
              <span class="o">|&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">adjustment</span>
       <span class="n">posy</span> <span class="o">=</span> <span class="n">position</span><span class="o">.</span><span class="n">y</span>
              <span class="o">|&gt;</span> <span class="n">toFloat</span>
              <span class="o">|&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">adjustment</span>
              <span class="o">|&gt;</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span>
       <span class="n">newX</span> <span class="o">=</span> <span class="n">retarget</span> <span class="n">model</span><span class="o">.</span><span class="n">clock</span> <span class="n">posx</span> <span class="n">model</span><span class="o">.</span><span class="n">x</span>
       <span class="n">newY</span> <span class="o">=</span> <span class="n">retarget</span> <span class="n">model</span><span class="o">.</span><span class="n">clock</span> <span class="n">posy</span> <span class="n">model</span><span class="o">.</span><span class="n">y</span>
   <span class="kr">in</span>
       <span class="p">({</span><span class="n">model</span> <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span> <span class="p">}</span> <span class="o">|&gt;</span> <span class="n">update</span> <span class="kt">PlaySound</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="音を鳴らす">音を鳴らす</h2>

<p>このアプリを作るときに一番わかりにくかったところはクリックされたときに音を鳴らす動作です。Javascriptだと <code class="language-plaintext highlighter-rouge">audio</code> 要素を取得して <code class="language-plaintext highlighter-rouge">play</code> 関数を呼ぶだけなんですが <code class="language-plaintext highlighter-rouge">play</code> は副作用を及ぼす関数なので調べた限りではElmからは直接呼ぶことができませんでした。そこで <code class="language-plaintext highlighter-rouge">Port</code> の出番です。</p>

<p>Portの仕組みはとても簡単で、Javascript側でElmからのメッセージをサブスクライブして何か送られてきたら使いたいJavascriptのコードを実行するだけです。今回の例だと、Elmが音を鳴らしたいときにPortにメッセージを送り、Javascript側で <code class="language-plaintext highlighter-rouge">audio</code> 要素を取得して <code class="language-plaintext highlighter-rouge">play</code> を呼ぶだけです。</p>

<p>まずJavascript側から説明します。このコードは <code class="language-plaintext highlighter-rouge">index.html</code> に書かれています。</p>

<p><code class="language-plaintext highlighter-rouge">app.ports.play.subscribe(function(val){...})</code> がElmからPortにメッセージが送られてきた時に呼ばれるコールバックです。単純に <code class="language-plaintext highlighter-rouge">audio</code> 要素を取得して <code class="language-plaintext highlighter-rouge">play</code> しているところがメインです。(一度 <code class="language-plaintext highlighter-rouge">pause</code> しているのは音が終わる前にもう一度クリックされた時に最初から再生するためにです。)</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body</span> <span class="na">background=</span><span class="s">"images/sky.jpg"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;audio</span> <span class="na">id=</span><span class="s">"my-audio"</span> <span class="na">src=</span><span class="s">"audios/flee1.mp3"</span><span class="nt">&gt;&lt;/audio&gt;</span>
    <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
     <span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">Elm</span><span class="p">.</span><span class="nx">Main</span><span class="p">.</span><span class="nx">fullscreen</span><span class="p">();</span>

     <span class="c1">// Triggered from Elm</span>
     <span class="nx">app</span><span class="p">.</span><span class="nx">ports</span><span class="p">.</span><span class="nx">play</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
         <span class="kd">var</span> <span class="nx">audio</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">my-audio</span><span class="dl">'</span><span class="p">);</span>
         <span class="nx">audio</span><span class="p">.</span><span class="nx">pause</span><span class="p">();</span>
         <span class="nx">audio</span><span class="p">.</span><span class="nx">currentTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="nx">audio</span><span class="p">.</span><span class="nx">play</span><span class="p">();</span>
     <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>次にPortにメッセージを送る側のElmコードを見てみます。Updateの中で <code class="language-plaintext highlighter-rouge">PlaySound</code> を捕まえます。 <code class="language-plaintext highlighter-rouge">PlaySound</code> がどこからくるかというと <code class="language-plaintext highlighter-rouge">MouseMsg</code> をハンドリングする際に戻り値で手動で <code class="language-plaintext highlighter-rouge">update</code> を呼んで <code class="language-plaintext highlighter-rouge">PlaySound</code> のコマンドを渡しています。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">({</span><span class="n">model</span> <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">newX</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">newY</span> <span class="p">}</span> <span class="o">|&gt;</span> <span class="n">update</span> <span class="kt">PlaySound</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">play 0</code> と呼ぶとJavascript側でサブスクライブしているPortに <code class="language-plaintext highlighter-rouge">0</code> という値が送られます。ここではJavascript側は何も値は必要ないのですが引数なしで送る方法がわからなかったので適当な値を渡しているだけです。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">PlaySound</span> <span class="o">-&gt;</span>
    <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">play</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="まとめ">まとめ</h2>

<p>大事な点はだいたいカバーしたと思います。純粋関数言語からアニメーションを扱う考え方はとても面白かったです。はじめは少しとっつきにくいかもしれませんが、慣れれば他の似たようなライブラリも簡単に理解できるようになりました。</p>

<p>この記事を通してElmのファンが増えてくれれば嬉しいです!</p>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[この記事はQiita Elm Adventcalendar 2017に投稿した記事です。]]></summary></entry><entry><title type="html">My Investment Principles</title><link href="/blog/my-investment-principles/" rel="alternate" type="text/html" title="My Investment Principles" /><published>2017-11-24T11:34:00+09:00</published><updated>2017-11-24T11:34:00+09:00</updated><id>/blog/my-investment-principles</id><content type="html" xml:base="/blog/my-investment-principles/"><![CDATA[<p>投資について考える時間ができたので今の時点で投資に関して自分が大事にしていることをまとめておく。</p>

<p><strong>Note to future self:</strong> 時々見返して、適宜修正すること。</p>

<h2 id="1-投資の収入に期待してはいけない">1. 投資の収入に期待してはいけない</h2>

<p>投資を主な収入源にしている人たちにとっては大きなアンチテーゼだが、投資をする上での第一原則は投資の収入を大きく当てにしないこと。 理由は主に以下。</p>

<p>投資で儲けるためには時間かかる。そのため、これを当てにして生活プランを組むと無収入の期間が長く続いた時に精神的に辛い。追い詰められた時、人は大きなミスをしやすくなる。</p>

<p>できるだけ損切りしないというスタイルの場合 (後述)、評価損が逆転するまでに時間がかかる。同じくこの間は無収入になる。</p>

<p>また、投資を主な収入源にした場合、どうしても積極的になりがちで投資額が増えてしまうが、相場には時折破滅的な下落がある。資金に対して投資額が大きい時にそうゆう下落があった場合、最悪の場合資金を全て失う可能性がある。</p>

<p>我々は気楽な機関投資家とは違う。彼らは最悪の場合でも顧客の金を失うだけだが、こちらは資金の全て失うことがあることを常に覚えておかないといけない。</p>

<h2 id="2-時間は見方">2. 時間は見方</h2>

<p>1.の原則を守ることができれば二つ目の原則は自然と導かれる。アマチュア投資家の場合、いつまでに利益を出さないとかポートフォリオに評価損があったら
困るとかいうことはほとんどない。(ないようにしないといけない)。判断を間違えて評価損が出てしまった場合は”時間は見方”と自分に言い聞かせよう。</p>

<p>可能な限り損切りはせずにしばらく証券会社のサイトにはアクセスせずにほったらかしておこう。しばらくすれば、情勢は変わっているはず。</p>

<p>ただ、諸刃の剣でもあることを覚えておこう。銘柄の中にはいくら待っても好転しないものも沢山ある。例えば、２０１７年に東芝の株は暴落したがこれは将来好転しそうもない。したとしてもとても時間がかかるのは間違いない。待ってる間に東芝が破綻する可能性の方が高い。</p>

<p>こうゆう事態を避けるために下落すればまた必ず上昇するタイプの銘柄にしか投資してはいけない。しかし、残念ながら今の自分にはそれを正確に見極める術はない。</p>

<h2 id="3-相場は予想できない">3. 相場は予想できない</h2>

<p>常識に反し、相場は予測できるようなものではないと考える。過去を遡ることでこの主張が正しいことを簡単にテストできる。試しに <a href="https://jp.reuters.com">ロイター</a> で過去の記事を検索してみるといい。(検索キーワード例: ドル円 コラム) そうすればアナリストたちの主張がいかに場あたり的なものかがよくわかる。</p>

<p>また、一年前の予想など全く当たっていないこともわかる。例えば、一年前の記事を検索すると、2017/12月の時点でドル円相場に大きな影響を与えている北朝鮮問題について語っている人など一人もいない。もっとも予想が外れているといってアナリスト達を責めることはできない。様々な要素が複雑に絡みあう現実世界で１年後を予想するなんてことは土台、不可能なことなんだ。</p>

<p>未来の予想不可能性についてもっと詳しく知りたければ数学の複雑系を勉強することをお勧めする。また、不可能なのになぜそれでも人が予測をしたがるかはを知りたければ心理学や行動経済学をお勧めする。</p>

<h2 id="4-乗り遅れた時こそ辛抱">4. 乗り遅れた時こそ辛抱</h2>

<p>判断を間違えて投資のチャンスに乗り遅れた時は辛抱が大切になってくる。乗り遅れたことに気づいた時は大抵その相場に参加するにはもう遅い。
上昇相場は加速度的に上昇 (上昇している相場はさらに上昇する) することが多いように思うが、その分下げの圧力も高くなっていることを忘れてはいけない。</p>

<p>もし、乗り遅れたあとに 上昇相場に参加する時は高まる下げ圧力のことを念頭におき、遅れた分を取り返そうなどとは考えず、あくまで少額投資にしておくこと。</p>

<p>2の原則を守っていれば時間はあなたの見方となる。相場の風向きが変わるまで辛抱すること。</p>

<h2 id="5-分散しない">5. 分散しない</h2>

<p>相場には <strong>すべての卵を一つのカゴに入れるな</strong> という格言があるが、これはアマチュア投資家には当てはまらない。なるべく資金を分散せず少ない銘柄に注力すること。分散すると以下のような事態に陥る。</p>

<p>相場の動きが相反する複数の銘柄に投資した場合、値動きが両端の真ん中でくすぶってどっちつかずになることがある。そうなった場合、身動きできなくなってしまう。</p>

<p>世界経済が悪くなった時は分散している全ての銘柄が同時に下落する場合がある。山火事のことを考えてほしい。一つの場所の大きな火事なら対応はシンプルだが複数の場所が同時に火事になった場合、その対応は飛躍的に難しくなる。</p>

<p>常に自分のポートフォリオを確認して分散しすぎていないかをチェックすること。自分は３銘柄までと決めている。</p>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[投資について考える時間ができたので今の時点で投資に関して自分が大事にしていることをまとめておく。]]></summary></entry><entry><title type="html">Average Doesn’t Always Exist</title><link href="/blog/en/average-dne/" rel="alternate" type="text/html" title="Average Doesn’t Always Exist" /><published>2017-04-09T11:35:00+09:00</published><updated>2017-04-09T11:35:00+09:00</updated><id>/blog/en/average-dne</id><content type="html" xml:base="/blog/en/average-dne/"><![CDATA[<p>Up until now, I thought average always exists. We are dealing with average very often in real life: the average height of Japanese, the average rate of divorcing in US, and the average salary in France, etc. It seemed to me that if I take enough number of sample data, I can get average that reflects the reality very well.</p>

<p>Today I learned that this is not always the case. Average doesn’t always exist. Because the idea is very interesting to me, let me share the idea with you.</p>

<h2 id="average-in-coin-toss-game">Average in Coin Toss Game</h2>

<p>Let’s being with the case when average exists. I’ll use a very simple coin toss game. You flip a coin and you win $1 if the result is head. You win $0 or nothing if the result is tail. Very simple.</p>

<p>When you toss the coin multiple times, what’s the average of dollar you will win? You can get the average very easily by the following formula:</p>

<p><code class="language-plaintext highlighter-rouge">avg. = (total number of $ you won) / number of times you toss the coin</code></p>

<p>And you will see that the average is 0.5 because the chance of getting head is 1/2. But is it really so? Let’s confirm this by writing some code to simulate the game.</p>

<p>Here is a small Clojure code to simulate the game.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">toss-coin</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">do-coin-toss</span><span class="w"> </span><span class="p">[</span><span class="n">ite</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">avg</span><span class="w"> </span><span class="p">[]]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ite</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">float</span><span class="w"> </span><span class="n">avg</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">do</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">outcome</span><span class="w"> </span><span class="p">(</span><span class="nf">toss-coin</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">outcome</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">avg</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">n</span><span class="p">))))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">write-data</span><span class="w"> </span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">vec</span><span class="w"> </span><span class="p">(</span><span class="nf">map-indexed</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="n">item</span><span class="p">]</span><span class="w">
                           </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="n">item</span><span class="p">))</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w">
        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="s">"\n"</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span><span class="w">
        </span><span class="n">header</span><span class="w"> </span><span class="s">"n avg\n"</span><span class="w">
        </span><span class="n">file</span><span class="w"> </span><span class="s">"/tmp/coin-toss-result.txt"</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">header</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="no">:append</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="s">"\n"</span><span class="w"> </span><span class="no">:append</span><span class="w"> </span><span class="n">true</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Here is R program <code class="language-plaintext highlighter-rouge">draw.R</code> to draw a graph.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">commandArgs</span><span class="p">(</span><span class="n">trailingOnly</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"coin-toss.png"</span><span class="w">

</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.table</span><span class="p">(</span><span class="s2">"/tmp/coin-toss-result.txt"</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">))</span><span class="w">
</span><span class="n">png</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">$</span><span class="n">avg</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="o">=</span><span class="s2">"l"</span><span class="p">)</span><span class="w">
</span><span class="n">dev.off</span><span class="p">()</span><span class="w">
</span><span class="n">browseURL</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If you want to toss the coin 10 times and output the result to a text file, you can do <code class="language-plaintext highlighter-rouge">(write-data (do-coin-toss 10))</code> from REPL and run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rscript draw.R
``` from your terminal.

I'll denote n as the number of times you toss the coin for brevity from now on.

Here is the graph of the average when n is **10**.

![coin-toss-10](/assets/coin-toss-10.png)

As you can see, the average is very quickly approaching to **0.5**. Let's do the same thing with larger n.

When n is **1000**

![coin-toss-1000](/assets/coin-toss-1000.png)

When n is **10000**

![coin-toss-10000](/assets/coin-toss-10000.png)

By looking at these graphs, we can safely say that the average of dollar you win in this coin toss game is $0.5.

## When Average Doesn't Exist.

Now we are entering an interesting area where the average disappears. To illustrate this, we will make the coin toss game a bit more complicated.

This time, you keep flipping the coin until you get head and you will get **2 ^ (number of times you flip the coin)**.

For example, if your result is tail, tail, and then head, then you get **2 ^ 3** (because you flipped three times) which is $8. Let's call this game "coin-toss-unti-head" game.

Here is a Clojure code to simulate the coin-toss-until-head game.

```clojure
(defn exp [x n]
  (if (zero? n) 1
      (* x (exp x (dec n)))))

(defn toss-coin-until-head []
  (loop [n 1]
    (let [outcome (toss-coin)]
      (if (= 0 (toss-coin))
        (exp 2 n)
        (recur (+ n 1))))))

(defn do-coin-toss [ite]
  (loop [n 1 total 0 avg []]
    (if (&gt; n ite)
      (map float avg)
      (do
        (let [outcome (toss-coin)]
          (recur (+ n 1) (+ total outcome) (conj avg (/ total n))))))))

(defn write-data [col]
  (let [vec (map-indexed (fn [idx item]
                           (str idx " " item)) col)
        data (clojure.string/join "\n" vec)
        header "n avg\n"
        file "/tmp/coin-toss-result.txt"]
    (spit file header)
    (spit file data :append true)
    (spit file "\n" :append true)))

</code></pre></div></div>

<p>You can again run the code from REPL</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">write-data</span><span class="w"> </span><span class="p">(</span><span class="nf">do-coin-toss</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">toss-coin-until-head</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>and plot graphs with</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rscript draw.R
</code></pre></div></div>

<p>Let’s begin with <strong>n=10</strong>.</p>

<p><img src="/assets/coin-toss-until-head-10.png" alt="coin-toss-until-head-10" /></p>

<p>It looks like the average is approaching to somewhere around 2.5 but we are not fully sure yet. Let’s increase n and see if the average is really 2.5.</p>

<p>Here is the graph when n is 20 and you will probably be disappointed by looking at the graph: the average is approaching to 2.5 and  then suddenly there is a spike around <strong>n=20</strong> which pushes the average a way higher! You will also discover the pattern after <strong>n=20</strong>: the average is converging to a number but then you will see a spike shortly after the convergence.</p>

<p><img src="/assets/coin-toss-until-head-100.png" alt="coin-toss-until-head-100" /></p>

<p>Maybe we just haven’t tossed the coin enough times. Let’s keep going a bit further.</p>

<p>Here is the graph when n is 10000. It looks like this time the average is approaching to somewhere around 12. Did we finally discover the average?</p>

<p><img src="/assets/coin-toss-until-head-10000.png" alt="coin-toss-until-head-10000" /></p>

<p>It turns out we didn’t! This is very clear when you increase n to 50000.</p>

<p><img src="/assets/coin-toss-until-head-50000.png" alt="coin-toss-until-head-50000" /></p>

<p>Again, there is a spike around 30000 and we lost the average again. You can increase n as much as you want and you will never find a good average in this game.</p>

<h2 id="why-average-doesnt-exist">Why Average Doesn’t Exist?</h2>

<p>We can see why the average doesn’t exist with simple math.</p>

<p>You can calculate the average of normal coin-toss game with the following formula.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ave. = (probability of H) x $1 + (probably of T) x $0
</code></pre></div></div>

<p>Because both the probability of getting head (H) and tail (T) is 0.5, the average of dollar you will win becomes $0.5 which is what we’ve seen in the previous simulations.</p>

<p>Let’s compute the average for the coin-toss-until-head game. One big difference from the normal coin toss game is that
there are infinite numbers of different results of coin in this game. The result could be <strong>T H</strong> or <strong>T T H</strong> or <strong>T T T T T T H</strong> or whatever.</p>

<p>So we need to calculate all the possibilities. You can express this with the following formula.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ave. = (probability of H) x 2^1 + (probability of TH) x 2^2 + (probably of TTH) x 2^3 ......
</code></pre></div></div>

<p>When you plugin the actual probability to the formula above, this will become the following.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ave. = (1/2) x 2^1 + (1/2 x 1/2) x 2^2 + (1/2 x 1/2 x 1/2) x 2^3 ......
ave. = 1 + 1 + 1 ......
ave. = ∞ (infinity)
</code></pre></div></div>

<p>The average that you got is ∞ (infinity). In other words, average doesn’t exist.</p>

<p>What’s the implication of the idea that average doesn’t always exist in real life?</p>

<p>Another way of interpreting these graphs without average is that sometimes a super extreme event could happen. Because the impact of the event is astronomical, it skews the average and make it useless. So, if the model that you are studying is similar to the coin-toss-until-head game, you will see the same pattern. In fact, this model is often used to study extreme events such as a sudden collapse in a stock market.</p>

<h2 id="summary">Summary</h2>

<p>Hopefully, you will find this interesting. Time is running out, so I’ll stop here, but if you want to learn more, you can search “St. Petersburg paradox” or “Power Laws” to dive into the area deeper.</p>

<p>You can find code I used here at https://github.com/kimh/coin-toss</p>]]></content><author><name>kim hirokuni</name></author><category term="en" /><summary type="html"><![CDATA[Up until now, I thought average always exists. We are dealing with average very often in real life: the average height of Japanese, the average rate of divorcing in US, and the average salary in France, etc. It seemed to me that if I take enough number of sample data, I can get average that reflects the reality very well.]]></summary></entry><entry><title type="html">(Backend) Engineer Principles</title><link href="/blog/being-backend-engineer/" rel="alternate" type="text/html" title="(Backend) Engineer Principles" /><published>2017-02-08T11:44:00+09:00</published><updated>2017-02-08T11:44:00+09:00</updated><id>/blog/being-backend-engineer</id><content type="html" xml:base="/blog/being-backend-engineer/"><![CDATA[<h2 id="security-first">Security First</h2>

<p>Always remind yourself that security is the most important thing. It’s important because the impact of security breach is more severe than anything else.</p>

<p><strong>Risks have to be measured by the impact when that happens, not how likely it happens</strong></p>

<h2 id="dont-break-stuff">Don’t break stuff</h2>

<p>When backend breaks, everything on top of it will also break. Always pay attention to keep the backward compatibility.</p>

<p><strong>Backward compatibility for the win</strong></p>

<h2 id="dont-merge-prs-at-late-night">Don’t merge PRs at late night</h2>

<p>You have much weaker cognitive power than you believe at late night. Merging PRs with the weak cognitive power will likely break the principles noted here.
This is also important because you can’t test the consequence of your changes until next morning.</p>

<p><strong>Merging PRs at Friday night is a terrible thing to do</strong></p>

<h2 id="never-drink-during-working">Never drink during working</h2>

<p>This is too obvious to be warned :)</p>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[Security First]]></summary></entry><entry><title type="html">Fasting: what popular beliefs were (not) true for me</title><link href="/blog/fasting/" rel="alternate" type="text/html" title="Fasting: what popular beliefs were (not) true for me" /><published>2017-01-28T22:25:00+09:00</published><updated>2017-01-28T22:25:00+09:00</updated><id>/blog/fasting</id><content type="html" xml:base="/blog/fasting/"><![CDATA[<p>I’m finishing my third fasting and I thought it’s good to write a blog about my experience with fasting. If you google fasting on the internet, there are many articles that talk about good things about fasting and I wanted to write what facts are true and not true in my experience.</p>

<p>There is also one more reason why I decided to write a blog about fasting: it seems that fasting is less common in Western societies than in Asian societies. When I talked about my experience about fasting, almost all people with Western background looked very puzzled and thought like I’m crazy. In contrast, fasting seems more popular idea in Asia and I think it’s probably because there is much stronger influence of Buddhism in Asian countries than in Western countries.</p>

<p>Fasting is not a crazy thing to do. It’s a well established health management method. Hopefully, this article helps people who are not familiar with fasting to see what fasting actually looks like and get interested in fasting.</p>

<h2 id="my-fasting-experiences">My fasting experiences</h2>

<p>Different people have different experiences in fasting. It’s very common that one effect of fasting works very well for one person but completely doesn’t work for other person. So, I should first mention about my normal diet and fasting experiences so far.</p>

<p>I’ve done fasting three times so far in my life. The longest fasting was four days mostly only with water.</p>

<p>I think of my self as a person who eats less than average male: I normally skip lunch and eat once or twice in a day. I don’t eat much carbs, either. I think it’s not inaccurate to say that I’m not a big fan of eating. I certainly appreciate easting good food, but it’s kind ok if I don’t eat. This type of diet probably made it easy to start fasting. So if you are a person who loves eating, then starting fasting is a little harder.</p>

<p>Anyway, that’s my fasting experiences and diet. Let me talk about what has happened to my body and brain during fasting.</p>

<h4 id="day-1">Day 1</h4>

<p>The first day of fasting is the toughest time for me, especially at night. I can’t stop thinking of fatty food such as ramen or hamburger. During this period, I also want to drink more than usual but this is probably because of my drinking habit that I have at every night.</p>

<p>I feel a bit dull and I would say that my body is operating under 70% ~ 80% level of normal time. It’s not that terrible but I don’t feel very conformable, either.</p>

<p>I also felt that my brain is operating under 60% ~ 70% of normal time. I can’t think difficult things and don’t feel like doing something creative. I can still read books, write blogs, and learn new things but it requires a bit more focus than usual.</p>

<h4 id="day-2">Day 2</h4>

<p>I still can’t stop thinking about food in the second day, but this time thoughts about sweets such as chocolate or ice cream is hunting me instead of fatty food. I think this is because of the decrease in the blood sugar level.</p>

<p>I still feel a bit dull but not much difference from the first day.</p>

<p>I feel my brain is having a harder time than the first day and things easily slip my attention. In my first fasting, I gave a small damage to my car in a parking lot in a way that I normally don’t. My wife told me that I was totally out of it when I was trying to park my car.</p>

<p>However, it’s interesting that I normally have a better outcome for performing a task with mental and cognitive load if I focus on the task. For example, when I was cooking, I could be into it more than usual and my dish was great. I also could have read books with more focus than usual.</p>

<h4 id="day-3">Day 3</h4>

<p>The third day is almost the same as the second day.</p>

<h4 id="day-4">Day 4</h4>

<p>The forth day is a surprising day. I almost forget that I haven’t eaten for the last three days. I don’t feel dull anymore and my brain works as usual.</p>

<p>I don’t have many things to talk about in the forth day except that my body and brain are functioning almost the same as normal time. This is the point where I started seeing an illusion that I can live without eating anything. I think the attainment of the strange feeling that your body and brain work just like usual without any food is one of the interesting experiences to have during fasting.</p>

<h2 id="effects-that-match-popular-beliefs">Effects that match popular beliefs</h2>

<p>Ok, so these are what happened to my body and brain during fasting. If you google fasting, people talk about many good things that happen during and after fasting. Let me talk about which one was true and which one was not in my experience.</p>

<h4 id="weight-loss">Weight loss</h4>

<p>Normally, I lose 2.5 ~ 3 kg. I haven’t rebounded my weight, neither, but this is probably due to my diet in normal time.</p>

<h4 id="skin-regeneration">Skin regeneration</h4>

<p>This is one of the most significant effect of fasting for me. Before fasting, my skin was dry and a bit damaged but it gets better and better as I keep fasting. And it lasts for a few days after fasting. Although this is not a direct benefit for me (why would I care the condition of my facial skin?) I think this is a good reason try fasting if you have skin problems.</p>

<h4 id="increase-in-the-sense-of-taste-and-smell">Increase in the sense of taste and smell</h4>

<p>There is a dramatic increase here. I could smell food that my wife was cooking in downstairs much more strongly than normal time.</p>

<p>I also felt the taste of food more strongly than normal time during fasting. One day I drunk vegetable juice and I felt it has never been more tasty than before.</p>

<h2 id="effects-that-do-not-match-popular-beliefs">Effects that do not match popular beliefs</h2>

<p>There are certain things and experiences that people bring up as effects of fasting but the followings didn’t happen to me.</p>

<h4 id="amazing-recovery-meals">Amazing recovery meals</h4>

<p>I should say that my experiences with recovery meals is not as dramatic as other people say. Recovery meals are meals that you take to go back to normal diet after fasting. They have to be easy to digest and shouldn’t have a strong flavor. Many people talk that how amazing your recovery meals would be and they could be life-changing taste or something.</p>

<p>The first recovery meal was indeed amazing. However, the special feeling doesn’t last very long. I didn’t didn’t have any special feeling even in the second recovery meal.</p>

<p>I understand effects of fasting varies among people but I personally think the effect is exaggerated to make you believe fasting is a good thing to do.</p>

<h4 id="fecal-impaction">Fecal impaction</h4>

<p>Many people talk fecal impaction would happen during fasting. However, this never happens to me. It may be because it needs longer period of fasting but at least it didn’t happen with four days of fasting.</p>

<h4 id="detoxing">Detoxing</h4>

<p>This is another thing that many people talk about as an effect of fasting, but I’m not sure if this is true. More accurately, I don’t have a way to measure if detoxing is happening or not. But as much as I can sense, detoxing is not happening in my body.</p>

<h4 id="increased-creativity-and-thinking-power">Increased creativity and thinking power</h4>

<p>Some people say your creativity and thinking power gain during fasting. In the end, I think I could do more creative stuff than usual during fasting. What I mean by creative stuff is things such as reading books to learn new ideas, writing computer programs, and doing some deep thinking, etc. However, I don’t think this is an direct effect of fasting. I felt my cognitive level definitely decreased. Nonetheless, I could do these creative stuff in fasting days than in normal days because I was motivated. I had some sort of determination to make fasting successful and this determination allows me to make more efforts deliberately than usual.</p>

<h4 id="saving-time">Saving time</h4>

<p>Although this is a bit off the topic, this is one of the most interesting findings that I’ve had during fasting. You will be surprised how much time you are spending for eating and drinking in everyday life if you stop eating. Because I don’t need to spend time for eating, I could use the time for other things such as playing with my baby or reading books.</p>

<p>I think the realization that how much I spend time for easting was a very unique effect of fasting not talked much among people.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Is fasting interesting? Yes, it’s very interesting. I had many experiences that I could not have in normal time.</p>

<p>Did fasting bring much benefits to me? Not really. Most of benefits disappear only in a few days after fasting. The stress of not eating during fasting certainly doesn’t pay the benefits.</p>

<p>So, I think I’ll continue doing fasting occasionally but not as a health management but more like conducting experiments with my own body in order to sense something that I can’t during normal time.</p>]]></content><author><name>kim hirokuni</name></author><summary type="html"><![CDATA[I’m finishing my third fasting and I thought it’s good to write a blog about my experience with fasting. If you google fasting on the internet, there are many articles that talk about good things about fasting and I wanted to write what facts are true and not true in my experience.]]></summary></entry><entry><title type="html">Big ideas in 2017</title><link href="/blog/en/big-ideas-2017/" rel="alternate" type="text/html" title="Big ideas in 2017" /><published>2017-01-09T10:22:00+09:00</published><updated>2017-01-09T10:22:00+09:00</updated><id>/blog/en/big-ideas-2017</id><content type="html" xml:base="/blog/en/big-ideas-2017/"><![CDATA[<p>Here is a list of big ideas that I learned in 2017.</p>

<ul>
  <li>Time does not exist</li>
  <li>When you reach 30, there are more things NOT to do than to do</li>
</ul>]]></content><author><name>kim hirokuni</name></author><category term="en" /><summary type="html"><![CDATA[Here is a list of big ideas that I learned in 2017.]]></summary></entry></feed>